<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>50.054 Static Semantics For SIMP - Compiler Design and Program Analysis 50.054</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Compiler Design and Program Analysis 50.054</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../handout/" class="nav-link">Handout</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#50054-static-semantics-for-simp" class="nav-link">50.054 Static Semantics For SIMP</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#learning-outcomes" class="nav-link">Learning Outcomes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#what-is-static-semantics" class="nav-link">What is static semantics?</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#type-checking-for-simp" class="nav-link">Type Checking for SIMP</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#what-is-type-inference" class="nav-link">What is Type Inference</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#type-inference-for-simp-program" class="nav-link">Type inference for SIMP program</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="50054-static-semantics-for-simp">50.054 Static Semantics For SIMP</h1>
<h2 id="learning-outcomes">Learning Outcomes</h2>
<ol>
<li>Explain what static semantics is.</li>
<li>Apply type checking rules to verify the type correctness property of a SIMP program.</li>
<li>Explain the relation between type system and operational semantics.</li>
<li>Apply type inference algorithm to generate a type environment given a SIMP program.</li>
</ol>
<h2 id="what-is-static-semantics">What is static semantics?</h2>
<p>While dynamic semantics defines the run-time behavior of the given program, static semantics defines the compile-time properties of the given program.</p>
<p>For example, a <em>statically correct</em> program, must satisfy some properties</p>
<ol>
<li>all uses of variables in it must be defined somewhere earlier. </li>
<li>all the use of variables, the types must be matching with the expected type in the context.</li>
<li>... </li>
</ol>
<p>Here is a statically correct SIMP program,</p>
<pre><code class="language-java">x = 0;
y = input;
if y &gt; x {
    y = 0;
}
return y;
</code></pre>
<p>because it satifies the first two properties. </p>
<p>The following program is not statically correct.</p>
<pre><code class="language-java">x = 0;
y = input;
if y + x { // type error
    x = z; // the use of an undefined variable z
}
return x;
</code></pre>
<p>Static checking is to rule out the statically incorrect programs.</p>
<h2 id="type-checking-for-simp">Type Checking for SIMP</h2>
<p>We consider the type checking for SIMP programs.</p>
<p>Recall the syntax rules for SIMP</p>
<div class="arithmatex">\[
\begin{array}{rccl}
(\tt Statement) &amp; S &amp; ::= &amp; X = E ; \mid return\ X ; \mid nop; \mid if\ E\ \{ \overline{S} \}\ else\ \{ \overline{S} \} \mid while\ E\ \{ \overline{S} \} \\
(\tt Expression) &amp; E &amp; ::= &amp; E\ OP\ E \mid X \mid C  \mid (E) \\
(\tt Statements) &amp; \overline{S} &amp; ::= &amp; S \mid S\ \overline{S} \\
(\tt Operator) &amp; OP &amp; ::= &amp; + \mid - \mid * \mid &lt; \mid == \\ 
(\tt Constant) &amp; C &amp; ::= &amp; 0 \mid 1 \mid 2 \mid ... \mid true \mid false \\ 
(\tt Variable) &amp; X &amp; ::= &amp; a \mid b \mid c \mid d \mid ... \\ 
 {\tt (Types)} &amp; T &amp; ::= &amp; int \mid bool  \\ 
 {\tt (Type\ Environments)} &amp; \Gamma &amp; \subseteq &amp; (X \times T)
\end{array}
\]</div>
<p>We use the symbol <span class="arithmatex">\(\Gamma\)</span> to denote a type environments mapping SIMP variables to types. <span class="arithmatex">\(T\)</span> to denote a type.
We write <span class="arithmatex">\(dom(\Gamma)\)</span> to denote the domain of <span class="arithmatex">\(\Gamma\)</span>, i.e. <span class="arithmatex">\(\{ X \mid (x,T) \in \Gamma \}\)</span>. We assume for all <span class="arithmatex">\(x \in dom(\Gamma)\)</span>, there exists only one entry of <span class="arithmatex">\((x,T) \in \Gamma\)</span>.</p>
<p>We define two different relations, </p>
<ol>
<li><span class="arithmatex">\(\Gamma \vdash E : T\)</span>, which type-checks a SIMP expresion <span class="arithmatex">\(E\)</span> against a type <span class="arithmatex">\(T\)</span> under <span class="arithmatex">\(\Gamma\)</span>.</li>
<li><span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span>, which type-checks a SIMP statement sequence <span class="arithmatex">\(\overline{S}\)</span> under <span class="arithmatex">\(\Gamma\)</span>.</li>
</ol>
<h3 id="type-checking-rules-for-simp-expressions">Type checking rules for SIMP Expressions</h3>
<p>$$
\begin{array}{rc}
{\tt (tVar)} &amp; \begin{array}{c}
                (X,T) \in \Gamma
                \ \hline
                \Gamma \vdash X : T
                \end{array} 
\end{array}
$$
In the rule <span class="arithmatex">\({\tt (tVar)}\)</span>, we type check the variable <span class="arithmatex">\(X\)</span> having type <span class="arithmatex">\(T\)</span> under the type environment <span class="arithmatex">\(\Gamma\)</span> if we can find the entry <span class="arithmatex">\((X,T)\)</span> in <span class="arithmatex">\(\Gamma\)</span>.
$$
\begin{array}{rc}
{\tt (tInt)} &amp; \begin{array}{c}
                C\ {\tt is\ an\ integer}
                \ \hline
                \Gamma \vdash C : int
                \end{array} \ \ 
{\tt (tBool)} &amp; \begin{array}{c}
                C \in {true,false}
                \ \hline
                \Gamma \vdash C : bool
                \end{array} 
\end{array}
$$
In the rule <span class="arithmatex">\({\tt (tInt)}\)</span>, we type check an integer constant having type <span class="arithmatex">\(int\)</span>. Similarly, we type check a boolean constant having type <span class="arithmatex">\(bool\)</span>. 
$$
\begin{array}{rc}
{\tt (tOp1)} &amp; \begin{array}{c}
                \Gamma \vdash E_1:int \ \ \ \Gamma \vdash E_2:int\ \ \ OP \in { +, -, * }
                \ \hline
                \Gamma \vdash E_1\ OP\ E_2 : int
                \end{array} \ \ 
{\tt (tOp2)} &amp; \begin{array}{c}
                \Gamma \vdash E_1:int \ \ \ \Gamma \vdash E_2:int\ \ \ OP \in { ==, &lt;}
                \ \hline
                \Gamma \vdash E_1\ OP E_2 : bool
                \end{array} \ \
{\tt (tOp3)} &amp; \begin{array}{c}
                \Gamma \vdash E_1:bool \ \ \ \Gamma \vdash E_2:bool\ \ \ OP \in { ==, &lt;}
                \ \hline
                \Gamma \vdash E_1\ OP\ E_2 : bool
                \end{array} 
\end{array}
$$
In the rule <span class="arithmatex">\({\tt (tOp1)}\)</span>, we type check an integer arithmetic operation having type <span class="arithmatex">\(int\)</span>, if both operands can be type-checked against <span class="arithmatex">\(int\)</span>.
In the rule <span class="arithmatex">\({\tt (tOp2)}\)</span>, we type check an integer comparison operation having type <span class="arithmatex">\(bool\)</span>, if both operands can be type-checked against <span class="arithmatex">\(int\)</span>.
In the rule <span class="arithmatex">\({\tt (tOp3)}\)</span>, we type check a boolean comparison operation having type <span class="arithmatex">\(bool\)</span>, if both operands can be type-checked against <span class="arithmatex">\(bool\)</span>.
$$
\begin{array}{rc}
{\tt (tParen)} &amp; \begin{array}{c}
                \Gamma \vdash E :T
                \ \hline
                \Gamma \vdash (E) :T
                \end{array}
\end{array}
$$
Lastly in rule <span class="arithmatex">\({\tt (tParen)}\)</span>, we type check a parenthesized expression by type-checking the inner expression. </p>
<h3 id="type-checking-rules-for-simp-statements">Type Checking rules for SIMP Statements</h3>
<p>The typing rules for statement is in form of <span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span> instead of  <span class="arithmatex">\(\Gamma \vdash \overline{S} : T\)</span>, this is because
 statements do not return a value (except for return statement, which returns a value for the entire program.)</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (tSeq)} &amp; \begin{array}{c}
                \Gamma \vdash S \ \ \  \Gamma \vdash \overline{S}
                \\ \hline
                \Gamma \vdash S \overline{S}
               \end{array}
\end{array}
\]</div>
<p>The <span class="arithmatex">\({\tt (tSeq)}\)</span> rule type checks a non empty sequence of statement <span class="arithmatex">\(S \overline{S}\)</span> under the type environment <span class="arithmatex">\(\Gamma\)</span>.  It is typeable (a proof exists) iff if <span class="arithmatex">\(S\)</span> is typeable under <span class="arithmatex">\(\Gamma\)</span> and <span class="arithmatex">\(\overline{S}\)</span> is typeable under <span class="arithmatex">\(\Gamma\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (tAssign)} &amp; \begin{array}{c}
                \Gamma \vdash E : T \ \ \  \Gamma \vdash X : T
                \\ \hline
                \Gamma \vdash X = E 
               \end{array}
\end{array}
\]</div>
<p>The <span class="arithmatex">\({\tt (tAssign)}\)</span> rule type checks an assignment statement <span class="arithmatex">\(X = E\)</span> under <span class="arithmatex">\(\Gamma\)</span>. It is typeable if both <span class="arithmatex">\(X\)</span> and <span class="arithmatex">\(E\)</span> are typeable under <span class="arithmatex">\(\Gamma\)</span> respectively and their types agree.</p>
<div class="arithmatex">\[
\begin{array}{rc} 
{\tt (tReturn)} &amp; \begin{array}{c}
                \Gamma \vdash X : T
                \\ \hline
                \Gamma \vdash return\ X 
               \end{array} \\ \\ 
{\tt (tNop)} &amp; \Gamma \vdash nop 
\end{array}
\]</div>
<p>The <span class="arithmatex">\({\tt (tReturn)}\)</span> rule type checks the return statement. It is typeable, if the variable <span class="arithmatex">\(X\)</span> is typeable.
The <span class="arithmatex">\({\tt (tNop)}\)</span> rule type checks the nop statement, which is always typeable.</p>
<p>$$
\begin{array}{rc} 
{\tt (tIf)} &amp; \begin{array}{c}
                \Gamma \vdash E:bool \ \ \ \Gamma \vdash \overline{S_1} \ \ \ \Gamma \vdash \overline{S_2}
                \ \hline
                \Gamma \vdash if\ E\ {\overline{S_1}}\ else\ { \overline{S_2} } 
               \end{array} \ \ 
{\tt (tWhile)} &amp; \begin{array}{c}
                \Gamma \vdash E:bool \ \ \ \Gamma \vdash \overline{S}
                \ \hline
                \Gamma \vdash while\ E\ {\overline{S}} 
               \end{array} 
\end{array}
$$
The <span class="arithmatex">\({\tt (tIf)}\)</span> rule type checks the if-else statement, <span class="arithmatex">\(if\ E\ \{\overline{S_1}\}\ else\ \{ \overline{S_2} \}\)</span>. 
It is typeable if <span class="arithmatex">\(E\)</span> has type <span class="arithmatex">\(bool\)</span> under <span class="arithmatex">\(\Gamma\)</span> and both then- and else- branches are typeable under the <span class="arithmatex">\(\Gamma\)</span>.
The <span class="arithmatex">\({\tt (tWhile)}\)</span> rule type checks the while statement in a similar way.</p>
<p>We say that a SIMP program <span class="arithmatex">\(\overline{S}\)</span> is typeable under <span class="arithmatex">\(\Gamma\)</span>, i.e. it type checks with <span class="arithmatex">\(\Gamma\)</span> iff <span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span>.
On the other hand, we say that a SIMP program <span class="arithmatex">\(\overline{S}\)</span> is not typeable, i.e. it does not type check, iff there exists no <span class="arithmatex">\(\Gamma\)</span> such that <span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span>. </p>
<p>Let <span class="arithmatex">\(\Gamma = \{ (input, int), (x,int), (s,int) \}\)</span>, we consider the type checking derivation of </p>
<div class="arithmatex">\[x = input; s = 0; while\ s&lt;x\ \{ s = s + 1;\}\ return\ s;\]</div>
<pre><code class="language-java">                              Γ |- s:int (tVar)
                              Γ |- 0:int (tInt) 
Γ |- input:int (tVar)         -----------------(tAssign)   [sub tree 1]
Γ |- x:int (tVar)             Γ |- s=0  
------------------(tAssign)   --------------------------------------(tSeq)
Γ |- x=input;                 Γ |- s=0; while s&lt;x { s = s + 1;} return s; 
---------------------------------------------------------------------(tSeq)
Γ |- x=input; s=0; while s&lt;x { s = s + 1;} return s;
</code></pre>
<p>Where [sub tree 1] is</p>
<pre><code class="language-java">                                          Γ |- 0:int (tInt)
                                          Γ |- s:int (tVar)
Γ |- s:int (tVar)                         -----------------(tOp1)
Γ |- x:int (tVar)      Γ |-s:int (tVar)   Γ |- s+1:int 
--------------(tOp2)   -------------------------------(tAssign)
Γ |- s&lt;x:bool          Γ |- s = s + 1                   Γ |- s:int (tVar)
---------------------------------------------(tWhile)  ---------------(tReturn)
Γ |- while s&lt;x { s = s + 1;}                            Γ |- return s
--------------------------------------------------------------------(tSeq)
Γ |- while s&lt;x { s = s + 1;} return s; 
</code></pre>
<p>Note that the following two programs are not typeable.</p>
<pre><code class="language-java">// untypeable 1
x = 1;
y = 0;
if x {
    y = 0; 
} else {
    y = 1;
}
return y;
</code></pre>
<p>The above is untypeable because we use x of type <code>int</code> in a context where it is also expected as <code>bool</code>.</p>
<pre><code class="language-java">// untypeable 2
x = input;
if (x &gt; 1) {
    y = true;
} else {
    y = 0;
}
return y;
</code></pre>
<p>The above is unteable because we can't find a type environment which has both <code>(y,int)</code> and <code>(y,bool)</code>.</p>
<p>So far these two "counter" examples are bad programs. However we also note that our type system is too <em>conservative</em>.</p>
<pre><code class="language-java">// untypeable 3
x = input;
if (x &gt; 1) {
    if ( x * x * x &lt; x * x) {
        y = true;
    } else {
        y = 1;
    }
} else {
    y = 0;
}
return y;
</code></pre>
<p>Even though we note that when <code>x &gt; 1</code>, we have <code>x * x * x &lt; x * x == false</code> hence the statement <code>y = true</code> is not executed. Our type system still rejects this program.
We will discuss this issue in details in the upcoming units.</p>
<p>Let's connect the type-checking rules for SIMP with it dynamic semantics.</p>
<h3 id="definition-1-type-and-value-environments-consistency">Definition 1 - Type and Value Environments Consistency</h3>
<p>We say <span class="arithmatex">\(\Gamma \vdash \Delta\)</span> iff for all <span class="arithmatex">\((X,C) \in \Delta\)</span> we have <span class="arithmatex">\((X,T) \in \Gamma\)</span> and <span class="arithmatex">\(\Gamma \vdash C : T\)</span>. </p>
<p>It means the type environments and value environments are consistent.</p>
<h3 id="property-2-progress">Property 2 - Progress</h3>
<p>The following property says that a well typed SIMP program must not be stuck until it reaches the return statement.</p>
<p>Let <span class="arithmatex">\(\overline{S}\)</span> be a SIMP statement sequence. Let <span class="arithmatex">\(\Gamma\)</span> be a type environment such that <span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span>.
Then <span class="arithmatex">\(\overline{S}\)</span> is either 
1. a return statement, or 
1. a sequence of statements, and there exist <span class="arithmatex">\(\Delta\)</span>, <span class="arithmatex">\(\Delta'\)</span> and <span class="arithmatex">\(\overline{S'}\)</span> such that <span class="arithmatex">\(\Gamma \vdash \Delta\)</span> and <span class="arithmatex">\((\Delta, \overline{S}) \longrightarrow (\Delta', \overline{S'})\)</span>.</p>
<h3 id="property-3-preservation">Property 3 - Preservation</h3>
<p>The following property says that the evaluation of a SIMP program does not change its typeability.</p>
<p>Let <span class="arithmatex">\(\Delta\)</span>, <span class="arithmatex">\(\Delta'\)</span> be value environments.
Let <span class="arithmatex">\(\overline{S}\)</span> and <span class="arithmatex">\(\overline{S'}\)</span> be SIMP statement sequences such that <span class="arithmatex">\((\Delta, \overline{S}) \longrightarrow (\Delta', \overline{S'})\)</span>. 
Let <span class="arithmatex">\(\Gamma\)</span> be a type environment such that <span class="arithmatex">\(\Gamma \vdash \Delta\)</span> and <span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span>.
Then <span class="arithmatex">\(\Gamma \vdash \Delta'\)</span> and <span class="arithmatex">\(\Gamma \vdash \overline{S'}\)</span>.</p>
<h2 id="what-is-type-inference">What is Type Inference</h2>
<p>Type inference is also known as type reconstruction is a static semantics analysis process that aims to reconstruct the missing (or omitted) typing info from the source programs. </p>
<p>For example, given the Scala program</p>
<pre><code class="language-scala">def f(x:Int) = x + 1
</code></pre>
<p>the Scala compiler is able to deduce that the return type of <code>f</code> is <code>Int</code>. </p>
<p>Likewise for the following SIMP program</p>
<pre><code class="language-java">y = y + 1
</code></pre>
<p>we can also deduce that <code>y</code> is a of type <code>int</code>.</p>
<p>What we aim to achieve is a sound and systematic process to deduce the omitted type information.</p>
<h2 id="type-inference-for-simp-program">Type inference for SIMP program</h2>
<p>Given a SIMP program <span class="arithmatex">\(\overline{S}\)</span>, the goal of type inference is to find the "best" type environment <span class="arithmatex">\(\Gamma\)</span> such that <span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span>.</p>
<p>Given that <span class="arithmatex">\(\Gamma\)</span> is a set of variable to type mappings, the "best" can be defined as the smallest possible set that make <span class="arithmatex">\(\overline{S}\)</span> typeable. This is also called the most general solution.</p>
<h3 id="definition-most-general-type-envrionment">Definition - Most general type (envrionment)</h3>
<p>Let <span class="arithmatex">\(\Gamma\)</span> be type environment and <span class="arithmatex">\(\overline{S}\)</span> be a sequence of SIMP statements, such that <span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span>. <span class="arithmatex">\(\Gamma\)</span> is the <em>most general</em> type environment iff for all <span class="arithmatex">\(\Gamma'\)</span> such that <span class="arithmatex">\(\Gamma' \vdash \overline{S}\)</span> we have <span class="arithmatex">\(\Gamma \subseteq \Gamma'\)</span>.</p>
<h3 id="type-inference-rules">Type Inference Rules</h3>
<p>We would like to design type inference process using a deduction system. First of all, let's introduce some extra meta syntax terms that serve as intermediate data structures.</p>
<div class="arithmatex">\[
\begin{array}{rccl}
{\tt (Extended\ Types)} &amp; \hat{T} &amp; ::=  &amp;\alpha \mid T \\ 
{\tt (Constraints)} &amp; \kappa &amp; \subseteq &amp; (\hat{T} \times \hat{T}) \\ 
{\tt (Type\ Substitution)} &amp; \Psi &amp; ::= &amp; [\hat{T}/\alpha] \mid [] \mid \Psi \circ \Psi 
\end{array}
\]</div>
<p>Where <span class="arithmatex">\(\alpha\)</span> denotes a type variable. <span class="arithmatex">\(\kappa\)</span> define a set of pairs of extended types that are supposed to be equal, e.g. <span class="arithmatex">\(\{ (\alpha, \beta), (\beta, int) \}\)</span> means <span class="arithmatex">\(\alpha = \beta \wedge \beta = int\)</span>.</p>
<p>Type substititution replace type variable to some other type. </p>
<div class="arithmatex">\[
\begin{array}{rcll}
\lbrack\rbrack\hat{T} &amp; = &amp; \hat{T} \\ 
\lbrack\hat{T}/\alpha\rbrack\alpha &amp; = &amp; \hat{T}  \\
\lbrack\hat{T}/\alpha\rbrack\beta &amp; = &amp; \beta &amp; if\ \alpha \neq \beta \\
\lbrack\hat{T}/\alpha\rbrack T &amp; = &amp; T 
\end{array}
\]</div>
<p>Type substiution can be <em>compositional</em>.</p>
<div class="arithmatex">\[
\begin{array}{rcll}
 (\Psi_1 \circ \Psi_2) \hat{T} &amp; = &amp; \Psi_1(\Psi_2(\hat{T}))
\end{array}
\]</div>
<p>The SIMP type inference rules are defined in terms of a deduction system consists of two type of rule forms. </p>
<h3 id="type-inference-rules-for-simp-statements">Type Inference Rules for SIMP statements</h3>
<p>The type inference rules for SIMP statements are described in a form of <span class="arithmatex">\(\overline{S} \vDash \kappa\)</span>, which reads give a sequence of statements <span class="arithmatex">\(\overline{S}\)</span>, we generate a set of type constraints <span class="arithmatex">\(\kappa\)</span>. 
$$
\begin{array}{rc}
{\tt (tiNOP)} &amp; nop\vDash {} \ \ 
{\tt (tiReturn)} &amp; return\ X \vDash {}<br />
\end{array}
$$
The <span class="arithmatex">\({\tt (tiNOP)}\)</span> rule handles the <span class="arithmatex">\(nop\)</span> statement, an empty constraint set is returned.  Similar observation applies to the return statement. 
$$
\begin{array}{rc}
{\tt (tiSeq)} &amp; \begin{array}{c} 
                S \vDash \kappa_1 \ \ \ \ \overline{S} \vDash \kappa_2
                \ \hline
                S \overline{S} \vDash \kappa_1 \cup \kappa_2 
                \end{array} 
\end{array}
$$
The <span class="arithmatex">\({\tt (tiSeq)}\)</span> rule generates the type constraints of a sequence statement <span class="arithmatex">\(S\overline{S}\)</span>. We can do so by first generate the constraints <span class="arithmatex">\(\kappa_1\)</span> from <span class="arithmatex">\(S\)</span> and <span class="arithmatex">\(\kappa_2\)</span> from <span class="arithmatex">\(\overline{S}\)</span> and union <span class="arithmatex">\(\kappa_1\)</span> and <span class="arithmatex">\(\kappa_2\)</span>.<br />
$$
\begin{array}{rc}
{\tt (tiAssign)} &amp;  \begin{array}{c}
                    E \vDash \hat{T}, \kappa 
                    \ \hline
                    X = E \vDash { (\alpha_X, \hat{T}) } \cup \kappa 
                    \end{array} \ \
\end{array}
$$</p>
<p>The inference rule for assignment statement requires the premise <span class="arithmatex">\(E \vDash \hat{T}, \kappa\)</span>, the inference for the expression <span class="arithmatex">\(E\)</span> returning the type of <span class="arithmatex">\(E\)</span> and a constraint set <span class="arithmatex">\(\kappa\)</span>, which will be discussed shortly. The <span class="arithmatex">\({\tt (tiAssign)}\)</span> rule "calls" the expression inference rule to generate the type <span class="arithmatex">\(\hat{T}\)</span> and the constraints <span class="arithmatex">\(\kappa\)</span>, it prepends an entry <span class="arithmatex">\((\alpha_X,\hat{T})\)</span> to <span class="arithmatex">\(\kappa\)</span> to ensure that <span class="arithmatex">\(X\)</span>'s type and the type of the assignment's RHS must agree. </p>
<p>$$
\begin{array}{rc}
{\tt (tiIf)} &amp; \begin{array}{c}
                E \vDash \hat{T_1},\kappa_1 \ \ \ \overline{S_2} \vDash \kappa_2 \ \ \ \ \overline{S_3} \vDash \kappa_3
                \ \hline
                if\ E\ {\overline{S_2}}\ else {\overline{S_3}} \vDash {(\hat{T_1}, bool)} \cup \kappa_1 \cup \kappa_2 \cup \kappa_3
                \end{array} \ \ 
\end{array}
$$
The inference rule for if-else statatement first infers the type of the conditional expression <span class="arithmatex">\(E\)</span>'s type has <span class="arithmatex">\(\hat{T_1}\)</span> and the constraints <span class="arithmatex">\(\kappa_1\)</span>. <span class="arithmatex">\(\kappa_2\)</span> and <span class="arithmatex">\(\kappa_3\)</span> are the constraints inferred from the then- and else-branches. The final result is forming a union of <span class="arithmatex">\(\kappa_1\)</span>, <span class="arithmatex">\(\kappa_2\)</span> and <span class="arithmatex">\(\kappa_3\)</span>, in addition, requiring <span class="arithmatex">\(E\)</span>'s type must be <span class="arithmatex">\(bool\)</span>. </p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (tiWhile)} &amp; \begin{array}{c}
                    E \vDash \hat{T_1}, \kappa_1 \ \ \ \ \overline{S_2} \vDash \kappa_2
                    \\ \hline
                    while\ E\ \{\overline{S_2}\} \vDash \{(\hat{T_1}, bool)\} \cup \kappa_1 \cup \kappa_2
                  \end{array} 
\end{array}
\]</div>
<p>The inference for while statement is very similar to if-else statement. We skip the explanation. </p>
<h3 id="type-inference-rules-for-simp-expressions">Type Inference Rules for SIMP expressions</h3>
<p>The type inference rules for the SIMP expressions are defined in a form of <span class="arithmatex">\(E \vDash \hat{T}, \kappa\)</span>. </p>
<div class="arithmatex">\[
\begin{array}{rc} 
{\tt (tiInt)} &amp; \begin{array}{c}
                C\ {\tt is\ an\ integer}
                \\ \hline
                C \vDash int, \{\}
                \end{array} \\ \\ 
{\tt (tiBool)} &amp; \begin{array}{c}
                C\ \in \{true, false\}
                \\ \hline
                C \vDash bool, \{\}
                \end{array} 
\end{array}
\]</div>
<p>When the expression is an integer constant, we return <span class="arithmatex">\(int\)</span> as the inferred type and an empty constraint set. Likewise for boolean constant, we return <span class="arithmatex">\(bool\)</span> and <span class="arithmatex">\(\{\}\)</span>. </p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (tiVar)} &amp; X \vDash \alpha_X, \{\} 
\end{array}
\]</div>
<p>The <span class="arithmatex">\({\tt (tiVar)}\)</span> rule just generates a "skolem" type variable <span class="arithmatex">\(\alpha_X\)</span> which is specifically "reserved" for variable <span class="arithmatex">\(X\)</span>. A skolem type variable is a type variable that is free in the current context but it has a specific "purpose".</p>
<blockquote>
<p>For detailed explanation of skolem variable, refer to <a href="https://stackoverflow.com/questions/12719435/what-are-skolems">https://stackoverflow.com/questions/12719435/what-are-skolems</a> and <a href="https://en.wikipedia.org/wiki/Skolem_normal_form">https://en.wikipedia.org/wiki/Skolem_normal_form</a>.</p>
</blockquote>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (tiOp1)} &amp; \begin{array}{c}
                OP \in \{+, -, *\} \ \ \ E_1 \vDash \hat{T_1}, \kappa_1\ \ \ \ E_2 \vDash \hat{T_2}, \kappa_2
                \\ \hline
                E_1\ OP\ E_2 \vDash int, \{(\hat{T_1}, int), (\hat{T_2}, int)\} \cup \kappa_1 \cup \kappa_2
                \end{array} \\ \\ 
{\tt (tiOp2)} &amp; \begin{array}{c}
                OP \in \{&lt;, ==\} \ \ \ E_1 \vDash \hat{T_1}, \kappa_1\ \ \ \ E_2 \vDash \hat{T_2}, \kappa_2
                \\ \hline
                E_1\ OP\ E_2 \vDash bool, \{(\hat{T_1}, \hat{T_2})\} \cup \kappa_1 \cup \kappa_2
                \end{array}
\end{array}
\]</div>
<p>The rules <span class="arithmatex">\({\tt (tiOp1)}\)</span> and <span class="arithmatex">\({\tt (tiOp2)}\)</span> infer the type of binary operation expressions. Note that they can be broken into 6 different rules to be syntax-directed. <span class="arithmatex">\({\tt (tiOp1)}\)</span> is applied when the operator is an arithmethic operation, the returned type is <span class="arithmatex">\(int\)</span> and the inferred constraint set is the union of the constraints inferred from the operands plus the entries of enforcing both <span class="arithmatex">\(\hat{T_1}\)</span> and <span class="arithmatex">\(\hat{T_2}\)</span> are <span class="arithmatex">\(int\)</span>. <span class="arithmatex">\({\tt (tiOp2)}\)</span> supports the case where the operator is a boolean comparison. </p>
<p>$$
\begin{array}{rc}
{\tt (tiParen)} &amp; \begin{array}{c}
                  E \vDash \hat{T}, \kappa
                  \ \hline
                  (E) \vDash \hat{T}, \kappa
                  \end{array}
\end{array}
$$
The inference ruel for parenthesis expression is trivial, we infer the type from the inner expression.</p>
<h3 id="unification">Unification</h3>
<p>To solve the set of generated type constraints from the above inference rules, we need to use a unification algorithm. </p>
<div class="arithmatex">\[
\begin{array}{rcl}
mgu(int, int) &amp; = &amp; [] \\ 
mgu(bool, bool) &amp; = &amp; [] \\ 
mgu(\alpha, \hat{T}) &amp; = &amp; [\hat{T}/\alpha] \\ 
mgu(\hat{T}, \alpha) &amp; = &amp; [\hat{T}/\alpha] \\
\end{array}
\]</div>
<p>The <span class="arithmatex">\(mgu(\cdot, \cdot)\)</span> function generates a type substitution that unifies the two arguments. <span class="arithmatex">\(mgu\)</span> is a short hand for <em>most general unifier</em>. Note that <span class="arithmatex">\(mgu\)</span> function is a partial function, cases that are not mentioned in the above will result in a unification failure. </p>
<p>At the moment <span class="arithmatex">\(mgu\)</span> only unifies two extended types. We overload <span class="arithmatex">\(mgu()\)</span> to apply to a set of constraints as follows</p>
<div class="arithmatex">\[
\begin{array}{rcl}
mgu(\{\}) &amp; = &amp; [] \\ 
mgu(\{(\hat{T_1}, \hat{T_2})\} \cup \kappa ) &amp; = &amp; let\ \Psi_1 = mgu(\hat{T_1}, \hat{T_2}) \\ 
&amp; &amp; \ \ \ \ \ \ \kappa'  = \Psi_1(\kappa) \\ 
&amp; &amp; \ \ \ \ \ \ \Psi_2   = mgu(\kappa') \\ 
&amp; &amp; in\  \Psi_2 \circ \Psi_1  
\end{array}
\]</div>
<p>There are two cases.</p>
<ol>
<li>the constraint set is empty, we return the empty (identity) substitution.</li>
<li>the constriant set is non-empty, we apply the first version of <span class="arithmatex">\(mgu\)</span> to unify one entry <span class="arithmatex">\((\hat{T_1}, \hat{T_2})\)</span>, which yields a subsitution <span class="arithmatex">\(\Psi_1\)</span>. We apply <span class="arithmatex">\(\Psi_1\)</span> to the rest of the constraints <span class="arithmatex">\(\kappa\)</span> to obtain <span class="arithmatex">\(\kappa'\)</span>. Next we apply <span class="arithmatex">\(mgu\)</span> to <span class="arithmatex">\(\kappa'\)</span> recursively to generate another type substitution <span class="arithmatex">\(\Psi_2\)</span>. The final result is a composition of <span class="arithmatex">\(\Psi_2\)</span> with <span class="arithmatex">\(\Psi_1\)</span>. </li>
</ol>
<p>Note that the choice of the particular entry <span class="arithmatex">\((\hat{T_1}, \hat{T_2})\)</span> does not matter, the algorithm will always produce the same result when we apply the final subsitution to all the skolem type variable <span class="arithmatex">\(\alpha_X\)</span>. We see that in an example shortly. </p>
<h3 id="an-example">An Example</h3>
<p>Consider the following SIMP program</p>
<pre><code class="language-java">x = input;          // (α_x, α_input)      
y = 0;              // (α_y, int)
while (y &lt; x) {     // (α_y, α_x)
    y = y + 1;      // (α_y, int)
}
</code></pre>
<p>For the ease of access we put the inferred constraint entry as comments next to the statements. The detail derivation of the inference algorithm is as follows</p>
<pre><code class="language-java">input|=α_input,{} (tiVar)
-------------------------(tiAssign)    [subtree 1]
x=input|={(α_x,α_input)}   
-----------------------------------------------------------------------------(tiSeq)
x=input; y=0; while (y&lt;x) { y=y+1; } return y; |= {(α_x,α_input),(a_y,int),(α_y,α_x)} 
</code></pre>
<p>Where [subtree 1] is as follows</p>
<pre><code class="language-java">y|=α_y,{} (tiVar)
0|=int,{} (tiInt)
------------------(tiAssign)   [subtree 2]
y=0|={(α_y,int)}
--------------------------------------------------------(tiSeq)
y=0; while (y&lt;x) { y=y+1; } return y; |= {(a_y,int),(α_y,α_x)} 
</code></pre>
<p>Where [subtree 2] is as follows</p>
<pre><code class="language-java">                        y|=α_y,{} (tiVar)
                        1|=int,{} (tiInt)
y|=α_y,{} (tiVar)       --------------(tiOp1)
x|=α_x,{} (tiVar)       y+1|=int,{(α_y,int)}
--------------(tiOp2)  ----------------------(tiAssign)
y&lt;x|=bool,{(α_y,α_x)}  y=y+1|= {(α_y,int)} 
---------------------------------------------(tiWhile) --------------(tiReturn)
while (y&lt;x) { y=y+1; } |= {(α_y,α_x),(α_y,int)}        return y|= {}
---------------------------------------------------------------------(tiSeq)
while (y&lt;x) { y=y+1; } return y; |= {(α_y,α_x),(α_y,int)} 
</code></pre>
<h3 id="from-type-substitution-to-type-environment">From Type Substitution to Type Environment</h3>
<p>To derive the inferred type environment, we apply the type substitution to all the type variabales we created. </p>
<p>Let <span class="arithmatex">\(V(\overline{S})\)</span> denote all the variables used in a SIMP program <span class="arithmatex">\(\overline{S}\)</span>.</p>
<p>Given a type substitution <span class="arithmatex">\(\Psi\)</span> obtained from the unification step, the type environment <span class="arithmatex">\(\Gamma\)</span> can be computed as follows,</p>
<div class="arithmatex">\[
\Gamma = \{ (X, \Psi(\alpha_X)) | X \in V(\overline{S}) \}
\]</div>
<p>Recall that the set of constraints generated from the running example is </p>
<div class="arithmatex">\[
\{(\alpha_x,\alpha_{input}),(\alpha_{y},int),(\alpha_{y},\alpha_{x})\} 
\]</div>
<h4 id="unification-from-left-to-right">Unification from left to right</h4>
<p>Suppose the unification progress pick the entries from left to right</p>
<div class="arithmatex">\[
\begin{array}{ll}
mgu(\{(\underline{\alpha_x,\alpha_{input}}),(\alpha_{y},int),(\alpha_{y},\alpha_{x})\}) &amp; \longrightarrow \\ 
let\ \Psi_1 = mgu(\alpha_x,\alpha_{input}) \\ 
\ \ \ \ \ \ \kappa_1 = \Psi_1\{(\alpha_{y},int),(\alpha_{y},\alpha_{x})\} \\ 
\ \ \ \ \ \ \Psi_2 = mgu(\kappa_1) \\
in\ \Psi_2 \circ \Psi_1  &amp; \longrightarrow \\ 
let\ \Psi_1 = [\alpha_{input}/ \alpha_x] \\ 
\ \ \ \ \ \ \kappa_1 = \Psi_1\{(\alpha_{y},int),(\alpha_{y},\alpha_{x})\} \\ 
\ \ \ \ \ \ \Psi_2 = mgu(\kappa_1) \\
in\ \Psi_2 \circ \Psi_1  &amp; \longrightarrow \\ 
let\ \Psi_1 = [\alpha_{input}/ \alpha_x] \\ 
\ \ \ \ \ \ \kappa_1 = \{(\alpha_{y},int),(\alpha_{y},\alpha_{input})\} \\ 
\ \ \ \ \ \ \Psi_2 = mgu(\kappa_1) \\
in\ \Psi_2 \circ \Psi_1 &amp; \longrightarrow 
\end{array}
\]</div>
<p>Where derivation of <span class="arithmatex">\(mgu(\kappa_1)\)</span> </p>
<p>$$
\begin{array}{ll}
mgu({(\underline{\alpha_{y},int}),(\alpha_{y},\alpha_{input})}) &amp; \longrightarrow \ 
let\ \Psi_{21} = mgu(\alpha_{y},int) \
\ \ \ \ \ \ \kappa_2 = \Psi_{21}{(\alpha_{y},\alpha_{input})} \ 
\ \ \ \ \ \ \Psi_{22} = mgu(\kappa_2) \ 
in\ \Psi_{22} \circ \Psi_{21} &amp; \longrightarrow \
let\ \Psi_{21} = [int/\alpha_{y}] \
\ \ \ \ \ \ \kappa_2 = \Psi_{21}{(\alpha_{y},\alpha_{input})} \ 
\ \ \ \ \ \ \Psi_{22} = mgu(\kappa_2) \ 
in\ \Psi_{22} \circ \Psi_{21} &amp; \longrightarrow \
let\ \Psi_{21} = [int/\alpha_{y}] \
\ \ \ \ \ \ \kappa_2 = {(int,\alpha_{input})} \ 
\ \ \ \ \ \ \Psi_{22} = mgu(\kappa_2) \ 
in\ \Psi_{22} \circ \Psi_{21} &amp; \longrightarrow \
let\ \Psi_{21} = [int/\alpha_{y}] \
\ \ \ \ \ \ \kappa_2 = {(int,\alpha_{input})} \ 
\ \ \ \ \ \ \Psi_{22} = [int/\alpha_{input}] \ 
in\ \Psi_{22} \circ \Psi_{21} &amp; \longrightarrow \
[int/\alpha_{input}] \circ [int/\alpha_{y}]
\end{array}
$$
Hence the final result is </p>
<div class="arithmatex">\[ 
[int/\alpha_{input}] \circ [int/\alpha_{y}] \circ [\alpha_{input}/ \alpha_x]
\]</div>
<p>We apply this type substitution to all the variables in the program.</p>
<div class="arithmatex">\[
\begin{array}{rl}
([int/\alpha_{input}] \circ [int/\alpha_{y}] \circ [\alpha_{input}/ \alpha_x])\alpha_{input} &amp; = \\  
([int/\alpha_{input}] \circ [int/\alpha_{y}])\alpha_{input} &amp; = \\  
[int/\alpha_{input}]  \alpha_{input} &amp; = \\  
int \\ \\ 
([int/\alpha_{input}] \circ [int/\alpha_{y}] \circ [\alpha_{input}/ \alpha_x])\alpha_{x} &amp; = \\  
([int/\alpha_{input}] \circ [int/\alpha_{y}])\alpha_{input} &amp; = \\  
[int/\alpha_{input}]  \alpha_{input} &amp; = \\  
int \\ \\ 
([int/\alpha_{input}] \circ [int/\alpha_{y}] \circ [\alpha_{input}/ \alpha_x])\alpha_{y} &amp; = \\  
([int/\alpha_{input}] \circ [int/\alpha_{y}]) \alpha_{y} &amp; = \\  
[int/\alpha_{input}] int &amp; = \\  
int \\ \\ 
\end{array}
\]</div>
<p>So we have computed the inferred type environment</p>
<div class="arithmatex">\[
\Gamma = \{(input, int), (x, int), (y,int) \}
\]</div>
<h4 id="unification-from-right-to-left">Unification from right to left</h4>
<p>Now let's consider a different of order of applying the <span class="arithmatex">\(mgu\)</span> function to the constraint set. Instead of going from left to right, we solve the constraints from right to left. </p>
<div class="arithmatex">\[
\begin{array}{ll}
mgu(\{(\alpha_x,\alpha_{input}),(\alpha_{y},int),(\underline{\alpha_{y},\alpha_{x}})\}) &amp; \longrightarrow \\ 
let\ \Psi_1 = mgu(\alpha_{y},\alpha_{x}) \\ 
\ \ \ \ \ \ \kappa_1 = \Psi_1\{(\alpha_x,\alpha_{input}),(\alpha_{y},int)\} \\ 
\ \ \ \ \ \ \Psi_2 = mgu(\kappa_1) \\
in\ \Psi_2 \circ \Psi_1  &amp; \longrightarrow \\ 
let\ \Psi_1 = [\alpha_{x}/ \alpha_y] \\ 
\ \ \ \ \ \ \kappa_1 = \Psi_1\{(\alpha_x,\alpha_{input}),(\alpha_{y},int)\} \\ 
\ \ \ \ \ \ \Psi_2 = mgu(\kappa_1) \\
in\ \Psi_2 \circ \Psi_1  &amp; \longrightarrow \\ 
let\ \Psi_1 = [\alpha_{x}/ \alpha_y] \\ 
\ \ \ \ \ \ \kappa_1 = \{(\alpha_x,\alpha_{input}),(\alpha_{x},int)\} \\ 
\ \ \ \ \ \ \Psi_2 = mgu(\kappa_1) \\
in\ \Psi_2 \circ \Psi_1 &amp; \longrightarrow 
\end{array}
\]</div>
<p>Where derivation of <span class="arithmatex">\(mgu(\kappa_1)\)</span> </p>
<div class="arithmatex">\[
\begin{array}{ll}
mgu(\{(\alpha_x,\alpha_{input}),(\underline{\alpha_{x},int})\}) &amp; \longrightarrow \\ 
let\ \Psi_{21} = mgu(\alpha_{x},int) \\
\ \ \ \ \ \ \kappa_2 = \Psi_{21}\{(\alpha_{x},\alpha_{input})\} \\ 
\ \ \ \ \ \ \Psi_{22} = mgu(\kappa_2) \\ 
in\ \Psi_{22} \circ \Psi_{21} &amp; \longrightarrow \\
let\ \Psi_{21} = [int/\alpha_{x}] \\
\ \ \ \ \ \ \kappa_2 = \Psi_{21}\{(\alpha_{x},\alpha_{input})\} \\ 
\ \ \ \ \ \ \Psi_{22} = mgu(\kappa_2) \\ 
in\ \Psi_{22} \circ \Psi_{21} &amp; \longrightarrow \\
let\ \Psi_{21} = [int/\alpha_{x}] \\
\ \ \ \ \ \ \kappa_2 = \{(int,\alpha_{input})\} \\ 
\ \ \ \ \ \ \Psi_{22} = mgu(\kappa_2) \\ 
in\ \Psi_{22} \circ \Psi_{21} &amp; \longrightarrow \\
let\ \Psi_{21} = [int/\alpha_{x}] \\
\ \ \ \ \ \ \kappa_2 = \{(int,\alpha_{input})\} \\ 
\ \ \ \ \ \ \Psi_{22} = [int/\alpha_{input}] \\ 
in\ \Psi_{22} \circ \Psi_{21} &amp; \longrightarrow \\
[int/\alpha_{input}] \circ [int/\alpha_{x}]
\end{array}
\]</div>
<p>Hence the final result is </p>
<div class="arithmatex">\[ 
[int/\alpha_{input}] \circ [int/\alpha_{x}] \circ [\alpha_{x}/ \alpha_y]
\]</div>
<p>We apply this type substitution to all the variables in the program.</p>
<div class="arithmatex">\[
\begin{array}{rl}
([int/\alpha_{input}] \circ [int/\alpha_{x}] \circ [\alpha_{x}/ \alpha_y])\alpha_{input} &amp; = \\  
([int/\alpha_{input}] \circ [int/\alpha_{x}])\alpha_{input} &amp; = \\  
[int/\alpha_{input}]  \alpha_{input} &amp; = \\  
int \\ \\ 
([int/\alpha_{input}] \circ [int/\alpha_{x}] \circ [\alpha_{x}/ \alpha_y])\alpha_{x} &amp; = \\  
([int/\alpha_{input}] \circ [int/\alpha_{x}])\alpha_{x} &amp; = \\  
[int/\alpha_{input}]  int &amp; = \\  
int \\ \\ 
([int/\alpha_{input}] \circ [int/\alpha_{x}] \circ [\alpha_{x}/ \alpha_y])\alpha_{y} &amp; = \\  
([int/\alpha_{input}] \circ [int/\alpha_{x}]) \alpha_{x} &amp; = \\  
[int/\alpha_{input}] int &amp; = \\  
int \\ \\ 
\end{array}
\]</div>
<p>So we have computed the inferred the same type environment</p>
<div class="arithmatex">\[
\Gamma = \{(input, int), (x, int), (y,int) \}
\]</div>
<p>In face regardless the order of picking entries from the constraint sets, we compute the same <span class="arithmatex">\(\Gamma\)</span>.  </p>
<blockquote>
<p>If you have time, you can try another order.</p>
</blockquote>
<h3 id="inputs-type">Input's type</h3>
<p>In our running example, our inference algorithm is able to infer the program's input type i.e. <span class="arithmatex">\(\alpha_{input}\)</span>.</p>
<p>This is not always possible. Let's consider the following program.</p>
<pre><code class="language-java">x = input;          // (α_x, α_input)      
y = 0;              // (α_y, int)
while (y &lt; 3) {     // (α_y, int)
    y = y + 1;      // (α_y, int)
}
</code></pre>
<p>In the genereated constraints, our algorithm can construct the subtitution </p>
<div class="arithmatex">\[[\alpha_{input}/\alpha_x] \circ [int/\alpha_y]\]</div>
<p>Which fails to "ground" type variables <span class="arithmatex">\(\alpha_{input}\)</span> and <span class="arithmatex">\(\alpha_x\)</span>. </p>
<p>We may argue that this is an ill-defined program as <code>input</code> and <code>x</code> are not used in the rest of the program, which should be rejected if we employ some name analysis, (which we will learn in the upcoming lesson). Hence we simply reject this kind of programs. </p>
<p>Alternatively, we can preset the type of the program, which is a common practice for many program languages. When generating the set of constraint <span class="arithmatex">\(\kappa\)</span>, we manually add an entry <span class="arithmatex">\((\alpha_{input}, int)\)</span> assuming the input's type is expected to be <span class="arithmatex">\(int\)</span>. </p>
<h3 id="uninitialized-variable">Uninitialized Variable</h3>
<p>There is another situatoin in which the inference algorithm fails to ground all the type variables.</p>
<pre><code class="language-java">x = z;              // (α_x, α_z)      
y = 0;              // (α_y, int)
while (y &lt; 3) {     // (α_y, int)
    y = y + 1;      // (α_y, int)
}
</code></pre>
<p>in this case, we can't ground <span class="arithmatex">\(\alpha_x\)</span> and <span class="arithmatex">\(\alpha_z\)</span> as <code>z</code> is not initialized before use. In this case we argue that such a program should be rejected either by the type inference or the name analysis.</p>
<h3 id="property-4-type-inference-soundness">Property 4: Type Inference Soundness</h3>
<p>The following property states that the type environment generated from a SIMP program by the type inference algorithm is able to type check the SIMP program.</p>
<p>Let <span class="arithmatex">\(\overline{S}\)</span> be a SIMP program and <span class="arithmatex">\(\Gamma\)</span> is a type environment inferred using the described inference algorithm. Then <span class="arithmatex">\(\Gamma \vdash \overline{S}\)</span>. </p>
<h3 id="property-5-principality">Property 5: Principality</h3>
<p>The following property states that the type environment generated from a SIMP program by the type inference algorithm is a principal type environment.</p>
<p>Let <span class="arithmatex">\(\overline{S}\)</span> be a SIMP program and <span class="arithmatex">\(\Gamma\)</span> is a type environment inferred using the described inference algorithm. Then <span class="arithmatex">\(\Gamma\)</span> is the most general type environment that can type-check <span class="arithmatex">\(\overline{S}\)</span>. </p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/jquery-3.6.0.min.js"></script>
        <script src="../../js/bootstrap.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../javascripts/mathjax.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
