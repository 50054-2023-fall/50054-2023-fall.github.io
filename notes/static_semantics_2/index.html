<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>50.054 Static Semantics for Lambda Calculus - Compiler Design and Program Analysis 50.054</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Compiler Design and Program Analysis 50.054</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../handout/" class="nav-link">Handout</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#50054-static-semantics-for-lambda-calculus" class="nav-link">50.054 Static Semantics for Lambda Calculus</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#learning-outcomes" class="nav-link">Learning Outcomes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#type-checking-for-lambda-calculus" class="nav-link">Type Checking for Lambda Calculus</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#type-inference-for-lambda-calculus" class="nav-link">Type Inference for Lambda Calculus</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="50054-static-semantics-for-lambda-calculus">50.054 Static Semantics for Lambda Calculus</h1>
<h2 id="learning-outcomes">Learning Outcomes</h2>
<ol>
<li>Apply type checking algorithm to type check a simply typed lambda calculus expression.</li>
<li>Apply Hindley Milner algorithm to type check lambda calculus expressions.</li>
<li>Apply Algorithm W to infer type for lambda calculus.</li>
</ol>
<h2 id="type-checking-for-lambda-calculus">Type Checking for Lambda Calculus</h2>
<p>To illustrate the proocess of type checking for lambda calculus, we consider adding types and type annotations to the lambda calculus language. </p>
<p>Recall the lambda calculus syntax, with the following adaptation</p>
<div class="arithmatex">\[
\begin{array}{rccl}
 {\tt (Lambda\ Terms)} &amp; t &amp; ::= &amp; x \mid \lambda x:T.t \mid t\ t \mid let\ x:T =\ t\ in\ t \mid  if\ t\ then\ t\ else\ t \mid t\ op\ t \mid c \mid fix\ t \\
 {\tt (Builtin\ Operators)} &amp; op &amp; ::= &amp; + \mid - \mid * \mid / \mid\ == \\
 {\tt (Builtin\ Constants)} &amp; c &amp; ::= &amp; 0 \mid 1 \mid ... \mid true \mid false \\
 {\tt (Types)} &amp; T &amp; ::= &amp; int \mid bool \mid T \rightarrow T \\ 
 {\tt (Type\ Environments)} &amp; \Gamma &amp; \subseteq &amp; (x \times T)
\end{array}
\]</div>
<p>The difference is that the lambda abstraction <span class="arithmatex">\(\lambda x:T.t\)</span> now carries a <em>type annotation</em> of the lambda-bound variable. (Similar observation applies to let-binding) <span class="arithmatex">\(T\)</span> is a type symbol which can be <span class="arithmatex">\(int\)</span> or <span class="arithmatex">\(bool\)</span> or a function type <span class="arithmatex">\(T \rightarrow T\)</span>. The <span class="arithmatex">\(\rightarrow\)</span> type operator is right associative, i.e. <span class="arithmatex">\(T_1 \rightarrow T_2 \rightarrow T_3\)</span> is parsed as <span class="arithmatex">\(T_1 \rightarrow (T_2 \rightarrow T_3)\)</span>. Let's call this extended version of lambda calculus as <em>Simply Typed Lambda Calculus</em>.</p>
<p>Note that all the existing definitions for dynamic semantics of lambda calculus can be brought-forward (and extended) to support Simply Typed Lambda Calculus. We omit the details.</p>
<p>We formalize the type-checking process in a <strong>relation</strong> <span class="arithmatex">\(\Gamma \vdash t : T\)</span>, where <span class="arithmatex">\(\Gamma\)</span> is a mapping from variables to types.
We write <span class="arithmatex">\(dom(\Gamma)\)</span> to denote the domain of <span class="arithmatex">\(\Gamma\)</span>, i.e. <span class="arithmatex">\(\{ X \mid (x,T) \in \Gamma \}\)</span>. We assume for all <span class="arithmatex">\(x \in dom(\Gamma)\)</span>, there exists only one entry of <span class="arithmatex">\((x,T) \in \Gamma\)</span>.</p>
<p>Since <span class="arithmatex">\(\Gamma \vdash t : T\)</span> is relation, what type-checking attempts to verify is the following. <em>Given a type environment <span class="arithmatex">\(\Gamma\)</span> and lambda term <span class="arithmatex">\(t\)</span> and a type <span class="arithmatex">\(T\)</span>, <span class="arithmatex">\(t\)</span> can be given a type <span class="arithmatex">\(T\)</span> under <span class="arithmatex">\(\Gamma\)</span></em>.</p>
<div class="arithmatex">\[
\begin{array}{cc}
{\tt (lctInt)} &amp; \begin{array}{c} \\
                      c\ {\tt is\ an\ integer}
                      \\ \hline
                      \Gamma \vdash c : int
                      \end{array} \\ \\  
{\tt (lctBool)} &amp; \begin{array}{c} 
                      c\in \{ true, false\}
                      \\ \hline
                      \Gamma \vdash c : bool
                      \end{array}
\end{array}
\]</div>
<p>The rule <span class="arithmatex">\({\tt (lctInt)}\)</span> checks whether the given constant value is an integer.
The rule <span class="arithmatex">\({\tt (lctBool)}\)</span> checks whether the given constant value is a boolean.</p>
<div class="arithmatex">\[
\begin{array}{cc}
{\tt (lctVar)} &amp; \begin{array}{c} 
               (x, T) \in \Gamma  \\
               \hline
               \Gamma \vdash x : T 
               \end{array} 
\end{array}
\]</div>
<p>In rule <span class="arithmatex">\({\tt (lctVar)}\)</span>, we type check a variable <span class="arithmatex">\(x\)</span> against a type <span class="arithmatex">\(T\)</span>, which is only valid where <span class="arithmatex">\((x,T)\)</span> can be found in the type environment <span class="arithmatex">\(\Gamma\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{cc}
{\tt (lctLam)} &amp; \begin{array}{c}
               \Gamma \oplus (x, T) \vdash t : T'  \\
               \hline
               \Gamma \vdash \lambda x : T.t :T \rightarrow T' 
               \end{array} 
\end{array}
\]</div>
<p>In rule <span class="arithmatex">\({\tt (lctLam)}\)</span>, we type check a lambda abstraction against a type <span class="arithmatex">\(T\rightarrow T'\)</span>. This is only valid if the body of the lambda expression <span class="arithmatex">\(t\)</span> has type <span class="arithmatex">\(T'\)</span> under the extended type environment <span class="arithmatex">\(\Gamma \oplus (x, T)\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{cc}
{\tt (lctApp)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : T_1 \rightarrow T_2 \ \ \ \
               \Gamma \vdash t_2 : T_1 \\
               \hline
               \Gamma \vdash  t_1\ t_2 :T_2 
               \end{array} 
\end{array}
\]</div>
<p>In rule <span class="arithmatex">\({\tt (lctApp)}\)</span>, we type check a function application, applying <span class="arithmatex">\(t_1\)</span> to <span class="arithmatex">\(t_2\)</span>, against a type <span class="arithmatex">\(T_2\)</span>. This is only valid if <span class="arithmatex">\(t_1\)</span> is having type <span class="arithmatex">\(T_1 \rightarrow T_2\)</span> and <span class="arithmatex">\(t_2\)</span> is having type <span class="arithmatex">\(T_1\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{cc}
{\tt (lctLet)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : T_1 \ \ \ \
               \Gamma \oplus (x, T_1) \vdash t_2 : T_2 \\
               \hline
               \Gamma \vdash  let\ x:T_1 = t_1\ in\ t_2 :T_2 
               \end{array} 
\end{array}
\]</div>
<p>In rule <span class="arithmatex">\({\tt (lctLet)}\)</span>, we type check a let binding, <span class="arithmatex">\(let\ x:T_1 = t_1\ in\ t_2\)</span> against type <span class="arithmatex">\(T_2\)</span>. This is only valid if <span class="arithmatex">\(t_1\)</span> has type <span class="arithmatex">\(T_1\)</span> and <span class="arithmatex">\(t_2\)</span> has type <span class="arithmatex">\(T_2\)</span> under the extended environment  <span class="arithmatex">\(\Gamma \oplus (x, T_1)\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{cc}
{\tt (lctIf)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : bool \ \ \ \Gamma \vdash t_2 : T \ \ \ \ \Gamma \vdash t_3 : T \\
               \hline
               \Gamma \vdash  if\ t_1\ then\ t_2\ else\ t_3 : T 
               \end{array}
\end{array}
\]</div>
<p>In rule <span class="arithmatex">\({\tt (lctIf)}\)</span>, we type check a if-then-else expression against type <span class="arithmatex">\(T\)</span>. This is only valid if 
<span class="arithmatex">\(t_1\)</span> has type <span class="arithmatex">\(bool\)</span> and both <span class="arithmatex">\(t_1\)</span> and <span class="arithmatex">\(t_2\)</span> have type <span class="arithmatex">\(T\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{cc}
{\tt (lctOp1)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : int \ \ \ \Gamma \vdash t_2 : int \ \ \ op\in\{+,-,*,/\} \\
               \hline
               \Gamma \vdash  t_1\ op\ t_2 : int 
               \end{array} \\ \\ 
{\tt (lctOp2)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : int \ \ \ \Gamma \vdash t_2 : int \\
               \hline
               \Gamma \vdash  t_1\ ==\ t_2 : bool 
               \end{array} \\ \\ 
{\tt (lctOp3)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : bool \ \ \ \Gamma \vdash t_2 : bool \\
               \hline
               \Gamma \vdash  t_1\ ==\ t_2 : bool 
               \end{array} \\ \\ 
\end{array}
\]</div>
<p>The above three rules type check the binary operations. <span class="arithmatex">\({\tt (lctOp1)}\)</span> handles the case where the <span class="arithmatex">\(op\)</span> is an arithmatic operation, which requires both operands having type <span class="arithmatex">\(int\)</span>. <span class="arithmatex">\({\tt (lctOp2)}\)</span> and <span class="arithmatex">\({\tt (lctOp3)}\)</span> handle the case where <span class="arithmatex">\(op\)</span> is the equality test. In this case, the types of the operands must agree.</p>
<div class="arithmatex">\[
\begin{array}{cc}
{\tt (lctFix)} &amp; \begin{array}{c}
                \Gamma \vdash t : (T_1 \rightarrow T_2) \rightarrow T_1 \rightarrow T_2
                \\  \hline
                \Gamma \vdash fix\ t:T_1 \rightarrow T_2
               \end{array} 
\end{array}
\]</div>
<p>The last rule <span class="arithmatex">\({\tt (lctFix)}\)</span> type checks the fix operator application against the type <span class="arithmatex">\(T_1 \rightarrow T_2\)</span>. We enforce that the argument <span class="arithmatex">\(t\)</span> must be a fixed point function of type <span class="arithmatex">\((T_1 \rightarrow T_2) \rightarrow T_1 \rightarrow T_2\)</span>.</p>
<p>For example, we would like to type check the following simply typed lambda term.</p>
<p>$$
fix\ (\lambda f:int\rightarrow int.(\lambda x:int. (if\ x == 0\ then\ 1\ else\ (f\ (x-1))* x)))
$$
against the type <span class="arithmatex">\(int \rightarrow int\)</span></p>
<p>We added the optional parantheses for readability. </p>
<p>We find the the following type checking derivation (proof tree).</p>
<p>Let <code>Γ</code> be the initial type environment.</p>
<pre><code class="language-haskell">Γ⊕(f:int-&gt;int)⊕(x:int)|- x:int (lctVar)
Γ⊕(f:int-&gt;int)⊕(x:int)|- 0:int (lctInt)
---------------------------------------(lctOp2)  [sub tree 1]   [sub tree 2]
Γ⊕(f:int-&gt;int)⊕(x:int)|- x == 0: bool
------------------------------------------------------------------------------- (lctIf)
Γ⊕(f:int-&gt;int)⊕(x:int)|-if x == 0 then 1 else (f (x-1))*x:int
--------------------------------------------------------------------(lctLam)
Γ⊕(f:int-&gt;int)|-λx:int.(if x == 0 then 1 else (f (x-1))*x):int-&gt;int
--------------------------------------------------------------------------------(lctLam)
Γ |- λf:int-&gt;int.(λx:int.(if x == 0 then 1 else (f (x-1))*x)):(int-&gt;int)-&gt;int-&gt;int
---------------------------------------------------------------------------------(lctFix)
Γ |- fix (λf:int-&gt;int.(λx:int.(if x == 0 then 1 else (f (x-1))*x))):int-&gt;int
</code></pre>
<p>Let <code>Γ1=Γ⊕(f:int-&gt;int)⊕(x:int)</code>
Where [sub tree 1] is </p>
<pre><code class="language-haskell">Γ1|- 1:int (lctInt)
</code></pre>
<p>and [sub tree 2] is </p>
<pre><code class="language-haskell">                           Γ1|-x:int (lctVar) 
                           Γ1|-1:int (lctInt)
                           -----------------(lctOp1)
Γ1|- f:int-&gt;int (lctVar)   Γ1|- x-1:int 
-------------------------------------------------(lctApp)  
Γ1|- f (x-1):int                                           Γ1 |- x:int (lctVar)
-------------------------------------------------------------------------(lctOp1)
Γ1|- (f (x-1))*x:int
</code></pre>
<p>Another (counter) example which shows that we can't type check the following program </p>
<div class="arithmatex">\[
let\ x:int = 1\ in\ (if\ x\ then\ x\ else\ 0)
\]</div>
<p>against the type <span class="arithmatex">\(int\)</span>.</p>
<pre><code class="language-haskell">                   fail, no proof exists
                   ---------------------- 
                   Γ⊕(x:int)|- x:bool
                   ----------------------------------(lctIf)
Γ|-1:int (lctInt)  Γ⊕(x:int)|-if x then x else 0:int
--------------------------------------------------------(lctLet)
Γ|- let x:int = 1 in (if x then x else 0):int
</code></pre>
<h3 id="property-1-uniqueness">Property 1 - Uniqueness</h3>
<p>The following property states that if a lambda term is typable, its type must be unique.</p>
<p>Let <span class="arithmatex">\(t\)</span> be a simply typed lambda calculus term. Let <span class="arithmatex">\(\Gamma\)</span> be a type environment such that for all <span class="arithmatex">\(x \in fv(t)\)</span>, <span class="arithmatex">\(x \in dom(\Gamma)\)</span>. Let <span class="arithmatex">\(T\)</span> and <span class="arithmatex">\(T'\)</span> be types such that <span class="arithmatex">\(\Gamma \vdash t : T\)</span> and <span class="arithmatex">\(\Gamma \vdash t:T'\)</span>.
Then <span class="arithmatex">\(T\)</span> and <span class="arithmatex">\(T'\)</span> must be the same.</p>
<p>Where <span class="arithmatex">\(dom(\Gamma)\)</span> refers to the domain of <span class="arithmatex">\(\Gamma\)</span>, i.e. all the variables being mapped.</p>
<h3 id="property-2-progress">Property 2 - Progress</h3>
<p>The second property states that if a closed lambda term is typeable under the empty type environment, it must be runnable and not getting stuck.</p>
<p>Let <span class="arithmatex">\(t\)</span> be a simply typed lambda calculus term such that <span class="arithmatex">\(fv(t) = \{\}\)</span>. 
Let <span class="arithmatex">\(T\)</span> be a type such that <span class="arithmatex">\(\{\} \vdash t : T\)</span>.
Then <span class="arithmatex">\(t\)</span> is either a value or there exists some <span class="arithmatex">\(t'\)</span> such that <span class="arithmatex">\(t \longrightarrow t'\)</span>.</p>
<h3 id="property-3-preservation">Property 3 - Preservation</h3>
<p>The third property states that the type of a lambda term does not change over evaluation.</p>
<p>Let <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(t'\)</span> be simply typed lambda calculus terms such that <span class="arithmatex">\(t \longrightarrow t'\)</span>. Let <span class="arithmatex">\(T\)</span> be a type and <span class="arithmatex">\(\Gamma\)</span> be a type environment such that <span class="arithmatex">\(\Gamma \vdash t:T\)</span>.
Then <span class="arithmatex">\(\Gamma \vdash t':T\)</span>.</p>
<h3 id="issue-with-let-binding">Issue with let-binding</h3>
<p>The current type checking rules for Simply-typed Lambda Calculus fails to type check the following lambda calculus term.</p>
<div class="arithmatex">\[
\begin{array}{l}
let\ f = \lambda x:\alpha.x \\
in\ let\ g = \lambda x:int.\lambda y:bool.x \\ 
\ \ \ \ in\ (g\ (f\ 1)\ (f\ true))
\end{array}
\]</div>
<p>Where <span class="arithmatex">\(\alpha\)</span> denotes some generic type.
This is due to the fact that we can only give one type to <code>f</code>, either <span class="arithmatex">\(Int \rightarrow Int\)</span> or <span class="arithmatex">\(Bool \rightarrow Bool\)</span> but not both.</p>
<p>To type check the above program we need to get rid of the type annotations to the let binding (as well as lambda abstraction). This leads us to the <em>Hindley-Milner</em> Type System.</p>
<h3 id="hindley-milner-type-system">Hindley Milner Type System</h3>
<p>We define the lambda calculus syntax for Hindley Milner Type System as follows</p>
<div class="arithmatex">\[
\begin{array}{rccl}
 {\tt (Lambda\ Terms)} &amp; t &amp; ::= &amp; x \mid \lambda x.t \mid t\ t \mid let\ x =\ t\ in\ t \mid  if\ t\ then\ t\ else\ t \mid t\ op\ t \mid c \mid fix\ t \\
 {\tt (Builtin\ Operators)} &amp; op &amp; ::= &amp; + \mid - \mid * \mid / \mid\ == \\
 {\tt (Builtin\ Constants)} &amp; c &amp; ::= &amp; 0 \mid 1 \mid ... \mid true \mid false \\
 {\tt (Types)} &amp; T &amp; ::= &amp; int \mid bool \mid T \rightarrow T \mid \alpha \\ 
 {\tt (Type Scheme)} &amp; \sigma &amp; ::= &amp; \forall \alpha. \sigma \mid T \\ 
 {\tt (Type\ Environments)} &amp; \Gamma &amp; \subseteq &amp; (x \times \sigma ) \\
 {\tt (Type\ Substitution)} &amp; \Psi &amp; ::= &amp; [T/\alpha] \mid [] \mid \Psi \circ \Psi 
\end{array}
\]</div>
<p>In the above grammar rules, we remove the type annotations from the lambda abstraction and let binding. Our type inference algorithm should be able to recover them.  We add the type variable directly to the type <span class="arithmatex">\(T\)</span> rule instead of introducing the <span class="arithmatex">\(\hat{T}\)</span> rule for conciseness. We introduce a type scheme term <span class="arithmatex">\(\sigma\)</span> which is required for polymorphic types.  </p>
<p>We describe the Hindley Milner Type Checking rules as follows</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (hmInt)} &amp; \begin{array}{c} \\
                      c\ {\tt is\ an\ integer}
                      \\ \hline
                      \Gamma \vdash c : int
                      \end{array} \\ \\ 
{\tt (hmBool)} &amp; \begin{array}{c} 
                      c\in \{ true, false\}
                      \\ \hline
                      \Gamma \vdash c : bool
                      \end{array}
\end{array}
\]</div>
<p>The rules for constants remain unchanged. </p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (hmVar)} &amp; \begin{array}{c}
                (x,\sigma) \in \Gamma
                \\ \hline
                \Gamma \vdash x : \sigma
                \end{array} 
\end{array}
\]</div>
<p>The rule for variable is adjusted to use type signatures instead of types.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (hmLam)} &amp; \begin{array}{c}
               \Gamma \oplus (x, T) \vdash t : T'  \\
               \hline
               \Gamma \vdash \lambda x.t :T\rightarrow T' 
               \end{array} \\ \\ 
{\tt (hmApp)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : T_1 \rightarrow T_2 \ \ \ \
               \Gamma \vdash t_2 : T_1 \\
               \hline
               \Gamma \vdash  t_1\ t_2 :T_2 
               \end{array} 
\end{array}
\]</div>
<p>In rule <span class="arithmatex">\({\tt (hmLam)}\)</span> we type check the lambda abstraction against <span class="arithmatex">\(T\rightarrow T'\)</span>. It is largely the same as the <span class="arithmatex">\({\tt (lctLam)}\)</span> rule for simply typed lambda calculus, except that there is no type annotation to the lambda bound variable <span class="arithmatex">\(x\)</span>.
The rule <span class="arithmatex">\({\tt (hmApp)}\)</span> is exactly the same as <span class="arithmatex">\({\tt (lctApp)}\)</span>. </p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (hmFix)} &amp; \begin{array}{c}
                (fix,\forall \alpha. (\alpha\rightarrow \alpha)\rightarrow \alpha)\in \Gamma
                \\ \hline 
                \Gamma \vdash fix:\forall \alpha. (\alpha\rightarrow \alpha) \rightarrow \alpha
                \end{array}
\end{array}
\]</div>
<p>To type check the <span class="arithmatex">\(fix\)</span> operator, we assume that <span class="arithmatex">\(fix\)</span> is predefined in the language library and its type is given in the initial type environment <span class="arithmatex">\(\Gamma_{init}\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (hmIf)} &amp; \begin{array}{c}
                \Gamma \vdash t_1 : bool \ \ \ 
                \Gamma \vdash t_2 : \sigma \ \ \ 
                \Gamma \vdash t_3 : \sigma 
                \\ \hline
                \Gamma \vdash if\ t_1\ \{ t_2\}\ else \{ t_3 \}: \sigma
               \end{array} \\ \\ 
\end{array}
\]</div>
<p>We made minor adjustment to the rule handling if-else expression, by replacing <span class="arithmatex">\(T\)</span> with <span class="arithmatex">\(\sigma\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (hmOp1)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : int \ \ \ \Gamma \vdash t_2 : int \ \ \ op\in\{+,-,*,/\} \\
               \hline
               \Gamma \vdash  t_1\ op\ t_2 : int 
               \end{array} \\ \\ 
{\tt (hmOp2)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : int \ \ \ \Gamma \vdash t_2 : int \\
               \hline
               \Gamma \vdash  t_1\ ==\ t_2 : bool 
               \end{array} \\ \\ 
{\tt (hmOp3)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : bool \ \ \ \Gamma \vdash t_2 : bool \\
               \hline
               \Gamma \vdash  t_1\ ==\ t_2 : bool 
               \end{array} \\ \\  
\end{array}
\]</div>
<p>The type checking rules for binary operation remain unchanged.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (hmLet)} &amp; \begin{array}{c}
               \Gamma \vdash t_1 : \sigma_1 \ \ \ \
               \Gamma \oplus (x, \sigma_1) \vdash t_2 : T_2 \\
               \hline
               \Gamma \vdash  let\ x = t_1\ in\ t_2 :T_2 
               \end{array} \\ \\ 
{\tt (hmInst)} &amp; \begin{array}{c}
                \Gamma \vdash t : \sigma_1 \ \ \ \ \sigma_1 \sqsubseteq \sigma_2
                \\ \hline
                \Gamma \vdash t : \sigma_2
                \end{array} \\ \\ 
{\tt (hmGen)} &amp; \begin{array}{c}
                \Gamma \vdash t : \sigma \ \ \ \ \alpha \not\in ftv(\Gamma)
                \\ \hline 
                \Gamma \vdash t : \forall \alpha.\sigma
                \end{array}
\end{array}
\]</div>
<p>In the rule <span class="arithmatex">\({\tt (hmLet)}\)</span>, we first type check <span class="arithmatex">\(t_1\)</span> againt <span class="arithmatex">\(\sigma_1\)</span>, which is a type scheme, which allows <span class="arithmatex">\(t_1\)</span> to have a generic type. Under the extended type environment <span class="arithmatex">\(\Gamma \oplus (x, \sigma_1)\)</span> we type-check <span class="arithmatex">\(t_2\)</span>. </p>
<p>For the <span class="arithmatex">\({\tt (hmLet)}\)</span> rule to work as intended, we need two more rules, namely, <span class="arithmatex">\({\tt (hmInst)}\)</span> and <span class="arithmatex">\({\tt (hmGen)}\)</span>. In rule <span class="arithmatex">\({\tt (hmInst)}\)</span> we allow a term <span class="arithmatex">\(t\)</span> to be type-checked against <span class="arithmatex">\(\sigma_2\)</span>, provided we can type check it against <span class="arithmatex">\(\sigma_1\)</span> and <span class="arithmatex">\(\sigma_1 \sqsubseteq \sigma_2\)</span>.</p>
<h4 id="definition-type-instances">Definition - Type Instances</h4>
<p>Let <span class="arithmatex">\(\sigma_1\)</span> and <span class="arithmatex">\(\sigma_2\)</span> be type schemes. We say <span class="arithmatex">\(\sigma_1 \sqsubseteq \sigma_2\)</span> iff <span class="arithmatex">\(\sigma_1 = \forall \alpha. \sigma_1'\)</span> and there exists a type subsitution <span class="arithmatex">\(\Psi\)</span> such that <span class="arithmatex">\(\Psi(\sigma_1') = \sigma_2\)</span>.</p>
<p>In otherwords, we say <span class="arithmatex">\(\sigma_1\)</span> is more general that <span class="arithmatex">\(\sigma_2\)</span> and <span class="arithmatex">\(\sigma_2\)</span> is a type instance of <span class="arithmatex">\(\sigma_1\)</span>.</p>
<p>Finally the rule <span class="arithmatex">\({\tt (hmGen)}\)</span> generalizes existing type to type schemes. In this rule, if a term <span class="arithmatex">\(t\)</span> can be type-checked against a type scheme <span class="arithmatex">\(\sigma\)</span>, then <span class="arithmatex">\(t\)</span> can also be type-checked against <span class="arithmatex">\(\forall \alpha.\sigma\)</span> if <span class="arithmatex">\(\alpha\)</span> is not a free type variable in <span class="arithmatex">\(\Gamma\)</span>.</p>
<p>The type variable function <span class="arithmatex">\(ftv()\)</span> can be defined similar to the <span class="arithmatex">\(fv()\)</span> function we introduced for lambda caculus. </p>
<div class="arithmatex">\[
\begin{array}{rcl}
ftv(\alpha) &amp; = &amp; \{\alpha \} \\ 
ftv(int) &amp; = &amp; \{ \} \\
ftv(bool) &amp; = &amp; \{ \} \\
ftv(T_1 \rightarrow T_2) &amp; = &amp; ftv(T_1) \cup ftv(T_2) \\
ftv(\forall \alpha.\sigma) &amp; = &amp; ftv(\sigma) - \{ \alpha \} 
\end{array}
\]</div>
<p><span class="arithmatex">\(ftv()\)</span> is also overloaded to extra free type variables from a type environment.</p>
<div class="arithmatex">\[
\begin{array}{rcl}
ftv(\Gamma) &amp; = &amp; \{ \alpha \mid (x,\sigma) \in \Gamma \wedge \alpha \in ftv(\sigma) \}
\end{array}
\]</div>
<p>The application of a type substitution can be defined as </p>
<div class="arithmatex">\[
\begin{array}{rcll}
[] \sigma &amp; = &amp; \sigma \\ 
[T/\alpha] int &amp; = &amp; int \\
[T/\alpha] bool &amp; = &amp; bool \\ 
[T/\alpha] \alpha &amp; = &amp; T \\
[T/\alpha] \beta &amp; = &amp; \beta &amp; \beta \neq \alpha \\ 
[T/\alpha] T_1 \rightarrow T_2 &amp; = &amp; ([T/\alpha] T_1) \rightarrow ([T/\alpha] T_2) \\ 
[T/\alpha] \forall \beta. \sigma &amp; = &amp; \forall \beta. ([T/\alpha]\sigma) &amp; \beta \neq \alpha \wedge \beta \not \in ftv(T) \\ 
(\Psi_1 \circ \Psi_2)\sigma &amp; = &amp; \Psi_1 (\Psi_2 (\sigma))
\end{array}
\]</div>
<p>In case of applying a type subtitution to a type scheme, we need to check whether the quantified type variable <span class="arithmatex">\(\beta\)</span> is in conflict with the type substitution. In case of conflict, a renaming operation simiilar to <span class="arithmatex">\(\alpha\)</span> renaming will be applied to <span class="arithmatex">\(\forall \beta. \sigma\)</span>. </p>
<h4 id="example">Example</h4>
<p>Let's consider the type-checking derivation of our running (counter) example. </p>
<p>Let <code>Γ = {}</code> and <code>Γ1 = {(f,∀α.α-&gt;α)}</code>.</p>
<pre><code class="language-haskell">                           -------------------(hmVar)
                           Γ1⊕(x,β)⊕(y,γ)|-x:β 
                           --------------------(hmLam)
                           Γ1⊕(x,β)|-λy.x:γ-&gt;β
------------(hmVar)        -------------------(hmLam)
Γ⊕(x,α)|-x:α               Γ1|-λx.λy.x:β-&gt;γ-&gt;β   γ,β∉ftv(Γ1)
------------(hmLam)        --------------------------(hmGen)
Γ|-λx.x:α-&gt;α    α∉ftv(Γ)   Γ1|-λx.λy.x:∀β.∀γ.β-&gt;γ-&gt;β          [subtree 1]
-----------------(hmGen)   -------------------------------------------(hmLet)
Γ|-λx.x:∀α.α-&gt;α            Γ1|-let g = λx.λy.x in (g (f 1) (f true)):int    
------------------------------------------------------------------- (hmLet)
Γ|-let f = λx.x in (let g = λx.λy.x in (g (f 1) (f true)):int
</code></pre>
<p>Let <code>Γ2 = {(f,∀α.α-&gt;α), (g,∀β.∀γ.β-&gt;γ-&gt;β)}</code>, we find [subtree 1] is as follows</p>
<pre><code class="language-haskell">--------------------(hmVar)
Γ2|-g:∀β.∀γ.β-&gt;γ-&gt;β     ∀β.∀γ.β-&gt;γ-&gt;β ⊑ ∀γ.int-&gt;γ-&gt;int
----------------------------------(hmInst)
Γ2|-g:∀γ.int-&gt;γ-&gt;int                       [subtree 3]
-----------------------------------------------(hmApp)
Γ2|-g (f 1):∀γ.γ-&gt;int                      ∀γ.γ-&gt;int ⊑ bool-&gt;int 
-------------------------------------------------(hmInst)    
Γ2|-g (f 1):bool-&gt;int                                   [subtree 2]
---------------------------------------------------------------(hmApp)
Γ2|-g (f 1) (f true):int
</code></pre>
<p>Where [subtree 2] is as follows</p>
<pre><code class="language-haskell">--------------(hmVar)
Γ2|-f:∀α.α-&gt;α ∀α.α-&gt;α ⊑ bool-&gt;bool
-------------------(hmInst)       ----------------(hmBool)
Γ2|-f:bool-&gt;bool                  Γ2|-true:bool
----------------------------------------------------(hmApp)
Γ2|-f true:bool
</code></pre>
<p>Where [subtree 3] is as follows</p>
<pre><code class="language-haskell">--------------(hmVar)
Γ2|-f:∀α.α-&gt;α ∀α.α-&gt;α ⊑ int-&gt;int
-------------------(hmInst)       ----------------(hmInt)
Γ2|-f:int-&gt;int                    Γ2|-1:int
---------------------------------------------------(hmApp)
Γ2|-f 1:int
</code></pre>
<p>As we can observe, through the use of rules of <span class="arithmatex">\({\tt (hmGen)}\)</span> and <span class="arithmatex">\({\tt (hmVar)}\)</span>, we are able to give let-bound variables <code>f</code> and <code>g</code> some generic types (AKA parametric polymorphic types). Through rules <span class="arithmatex">\({\tt (hmApp)}\)</span> and <span class="arithmatex">\({\tt (hmInst)}\)</span> we are able to "instantiate" these polymoprhic types to the appropriate monomorphic types depending on the contexts. </p>
<p>Note that the goal of Hindley Milner type system is to store the most general (or principal) type (scheme) of a lambda term in the type environment, (especially the program variables and function names), so that when an application is being type-checked, we are able to instantiate a specific type based on the context, as we observe that it is always an combo of <span class="arithmatex">\({\tt (hmVar)}\)</span> rule followed by <span class="arithmatex">\({\tt (hmInst)}\)</span> rule.</p>
<h3 id="property-4-uniqueness">Property 4 - Uniqueness</h3>
<p>The following property states that if a lambda term is typable, its type scheme must be unique modulo type variable renaming.</p>
<p>Let <span class="arithmatex">\(t\)</span> be a lambda calculus term. Let <span class="arithmatex">\(\Gamma\)</span> be a type environment such that for all <span class="arithmatex">\(x \in fv(t)\)</span>, <span class="arithmatex">\(x \in dom(\Gamma)\)</span>. Let <span class="arithmatex">\(\sigma\)</span> and <span class="arithmatex">\(\sigma'\)</span> be type schemes such that <span class="arithmatex">\(\Gamma \vdash t : \sigma\)</span> and <span class="arithmatex">\(\Gamma \vdash t:\sigma'\)</span>.
Then <span class="arithmatex">\(\sigma\)</span> and <span class="arithmatex">\(\sigma'\)</span> must be the same modulo type variable renaming.</p>
<p>For instance, we say type schemes <span class="arithmatex">\(\forall \alpha.\alpha \rightarrow int\)</span> and <span class="arithmatex">\(\forall \beta.\beta \rightarrow int\)</span> are the same modulo type variable renaming. But type schemes <span class="arithmatex">\(\forall \alpha.\alpha \rightarrow bool\)</span> and <span class="arithmatex">\(\forall \beta.\beta \rightarrow int\)</span> are not the same.</p>
<h3 id="property-5-progress">Property 5 - Progress</h3>
<p>The Progress property is valid for Hindley Milner type checking.</p>
<p>Let <span class="arithmatex">\(t\)</span> be a lambda calculus term such that <span class="arithmatex">\(fv(t) = \{\}\)</span>. 
Let <span class="arithmatex">\(\sigma\)</span> be a type scheme such that <span class="arithmatex">\(\Gamma_{init} \vdash t : \sigma\)</span>.
Then <span class="arithmatex">\(t\)</span> is either a value or there exists some <span class="arithmatex">\(t'\)</span> such that <span class="arithmatex">\(t \longrightarrow t'\)</span>.</p>
<h3 id="property-6-preservation">Property 6 - Preservation</h3>
<p>The Presevation property is also held for Hindley Milner type checking.</p>
<p>Let <span class="arithmatex">\(t\)</span> and <span class="arithmatex">\(t'\)</span> be lambda calculus terms such that <span class="arithmatex">\(t \longrightarrow t'\)</span>. Let <span class="arithmatex">\(\sigma\)</span> be a type scheme and <span class="arithmatex">\(\Gamma\)</span> be a type environment such that <span class="arithmatex">\(\Gamma \vdash t:\sigma\)</span>.
Then <span class="arithmatex">\(\Gamma \vdash t':\sigma\)</span>.</p>
<h2 id="type-inference-for-lambda-calculus">Type Inference for Lambda Calculus</h2>
<p>To infer the type environment as well as the type for lambda calculus term, we need an algorithm called <em>Algorithm W</em>.</p>
<p>The algorithm is described in a deduction rule system of shape <span class="arithmatex">\(\Gamma, t \vDash T, \Psi\)</span>, which reads as given input type environment <span class="arithmatex">\(\Gamma\)</span> and a lambda term <span class="arithmatex">\(t\)</span>, the algorithm infers the type <span class="arithmatex">\(T\)</span> and type substitution <span class="arithmatex">\(\Psi\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (wInt)} &amp; \begin{array}{c}
                c\ {\tt is\ an\ integer} 
                \\ \hline 
               \Gamma, c \vDash int, [] 
               \end{array} \\ \\
{\tt (wBool)} &amp; \begin{array}{c}
                c\in \{true,false \} 
                \\ \hline 
               \Gamma, c \vDash bool, [] 
               \end{array}
\end{array}
\]</div>
<p>The rules for integer and boolean constants are straight forward. We omit the explanation.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (wVar)} &amp; \begin{array}{c}
                (x,\sigma) \in \Gamma \ \ \ inst(\sigma) = T
                \\ \hline 
               \Gamma, x \vDash T, [] 
               \end{array} \\ \\
{\tt (wFix)} &amp; \begin{array}{c}
                (fix,\forall \alpha. (\alpha\rightarrow \alpha)\rightarrow \alpha) \in \Gamma \ \ \ inst(\forall \alpha. (\alpha\rightarrow \alpha)\rightarrow \alpha) = T
                \\ \hline 
               \Gamma, fix \vDash T, [] 
               \end{array}
\end{array}
\]</div>
<p>The rule <span class="arithmatex">\({\tt (wVar)}\)</span> infers the type for a variable by looking it up from the input type environment <span class="arithmatex">\(\Gamma\)</span>.
Same observation applies to <span class="arithmatex">\({\tt (wFix)}\)</span> since we assume that <span class="arithmatex">\(fix\)</span> is pre-defined in the initial type environment <span class="arithmatex">\(\Gamma_{init}\)</span>, which serves as the starting input.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (wLam)} &amp; \begin{array}{c}
                \alpha_1 = newvar \ \ \ \Gamma \oplus (x,\alpha_1), t \vDash T, \Psi
                \\ \hline
                \Gamma, \lambda x.t \vDash : \Psi(\alpha_1 \rightarrow T ), \Psi
                \end{array}
\end{array}
\]</div>
<p>The rule <span class="arithmatex">\({\tt (wLam)}\)</span> infers the type for a lambda abstraction by "spawning" a fresh skolem type variable <span class="arithmatex">\(\alpha_1\)</span> which is reserved for the lambda bound variable <span class="arithmatex">\(x\)</span>. Under the extended type environment <span class="arithmatex">\(\Gamma \oplus (x,\alpha_1)\)</span> it infers the body of the lambda extraction <span class="arithmatex">\(t\)</span> to have type <span class="arithmatex">\(T\)</span> and the type substitution <span class="arithmatex">\(\Psi\)</span>. The inferred type of the entire lambda abstraction is therefore <span class="arithmatex">\(\Psi(\alpha_1 \rightarrow T)\)</span>. The reason is that while infering the type for the lambda body, we might obtain substitution that grounds <span class="arithmatex">\(\alpha_1\)</span>. For instance <span class="arithmatex">\(\lambda x. x + 1\)</span> will ground <span class="arithmatex">\(x\)</span>'s skolem type variable to <span class="arithmatex">\(int\)</span>.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (wApp)} &amp; \begin{array}{c}
                \Gamma, t_1 \vDash T_1, \Psi_1\ \ \ \ \Psi_1(\Gamma), t_2 \vDash T_2, \Psi_2\ \ \\ \alpha_3 = newvar\ \ \ \Psi_3 = mgu(\Psi_2(T_1), T_2 \rightarrow \alpha_3) 
                \\ \hline
                \Gamma, (t_1\ t_2) \vDash \Psi_3(\alpha_3), \Psi_3 \circ \Psi_2 \circ \Psi_1 
               \end{array}
\end{array}
\]</div>
<p>The rule <span class="arithmatex">\({\tt (wApp)}\)</span> infers the type for a function application <span class="arithmatex">\(t_1\ t_2\)</span>. We first apply the inference recursively to <span class="arithmatex">\(t_1\)</span>, producing a type <span class="arithmatex">\(T_1\)</span> and a type substitution <span class="arithmatex">\(\Psi_1\)</span>. Next we apply <span class="arithmatex">\(\Psi_1\)</span> to <span class="arithmatex">\(\Gamma\)</span> hoping to ground some of the type variables inside and use it to infer <span class="arithmatex">\(t_2\)</span>'s type as <span class="arithmatex">\(T_2\)</span> with a subsitution <span class="arithmatex">\(\Psi_2\)</span>. To denote the type of the application, we generate a fresh skolem type variable <span class="arithmatex">\(\alpha_3\)</span> reserved for this term. We perform a unification between <span class="arithmatex">\(\Psi_2(T_1)\)</span> (hoping <span class="arithmatex">\(\Psi_2\)</span> will ground some more type variables in <span class="arithmatex">\(T_1\)</span>), and <span class="arithmatex">\(T_2 \rightarrow \alpha_3\)</span>. If the unifcation is successful, it will result in another type substitution <span class="arithmatex">\(\Psi_3\)</span>. <span class="arithmatex">\(\Psi_3\)</span> can potentially ground the type variable <span class="arithmatex">\(\alpha_3\)</span>. At last we return <span class="arithmatex">\(\Psi_3(\alpha_3)\)</span> as the inferred type and composing all three substitutions as the resulted substitution.</p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (wLet)} &amp; \begin{array}{c}
                \Gamma, t_1 \vDash T_1, \Psi_1 \\ \Psi_1(\Gamma) \oplus (x, gen(\Psi_1(\Gamma), T_1)), t_2 \vDash T_2, \Psi_2
                \\ \hline
                \Gamma, let\ x=t_1\ in\ t_2 \vDash T_2, \Psi_2 \circ \Psi_1
             \end{array}
\end{array}
\]</div>
<p>The <span class="arithmatex">\({\tt (wLet)}\)</span> rule infers a type for the let binding. We first infer the type <span class="arithmatex">\(T_1\)</span> and type substitutions <span class="arithmatex">\(\Psi_1\)</span>. By applying <span class="arithmatex">\(\Psi_1\)</span> to <span class="arithmatex">\(\Gamma\)</span> we hope to ground some type variables in <span class="arithmatex">\(\Gamma\)</span>. We apply a helper function <span class="arithmatex">\(gen\)</span> to generalize <span class="arithmatex">\(T_1\)</span> w.r.t <span class="arithmatex">\(\Psi_1(\Gamma)\)</span>, and use it as the type for <span class="arithmatex">\(x\)</span> to infer <span class="arithmatex">\(t_2\)</span> type. Finally, we return <span class="arithmatex">\(T_2\)</span> as the inferred type and <span class="arithmatex">\(\Psi_2 \circ \Psi_1\)</span> as the type substitutions. </p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (wOp1)} &amp; \begin{array}{c}
                op \in \{+,-,*,/\} \\ 
                \Gamma, t_1 \vDash T_1, \Psi_1 \ \ \ \Psi_1(\Gamma), t_2 \vDash T_2, \Psi_2 \\ 
                mgu(\Psi_2(T_1), T_2, int) = \Psi_3   
                \\ \hline 
                \Gamma, t_1\ op\ t_2 \vDash int, \Psi_3 \circ \Psi_2 \circ \Psi_1 
                \end{array} \\ \\ 
{\tt (wOp2)} &amp; \begin{array}{c}
                \Gamma, t_1 \vDash T_1, \Psi_1 \ \ \ \Psi_1(\Gamma), t_2 \vDash T_2, \Psi_2 \\ 
                mgu(\Psi_2(T_1), T_2) = \Psi_3   
                \\ \hline 
                \Gamma, t_1\ ==\ t_2 \vDash bool, \Psi_3 \circ \Psi_2 \circ \Psi_1 
                \end{array}
\end{array}
\]</div>
<p>The rule <span class="arithmatex">\({\tt (wOp1)}\)</span> handles the type inference for arithmetic binary operation. The result type must be <span class="arithmatex">\(int\)</span>. In the premises, we infer the type of the left operand <span class="arithmatex">\(t_1\)</span> to be <span class="arithmatex">\(T_1\)</span> with a type substitution <span class="arithmatex">\(\Psi_1\)</span>. We apply <span class="arithmatex">\(\Psi_1\)</span> to <span class="arithmatex">\(\Gamma\)</span> hoping to ground some type variables. We continue to infer the right operand <span class="arithmatex">\(t_2\)</span> with a type <span class="arithmatex">\(T_2\)</span> and <span class="arithmatex">\(\Psi_2\)</span>. Finally we need to unify 
<span class="arithmatex">\(\Psi_2(T_1)\)</span>, <span class="arithmatex">\(T_2\)</span> and <span class="arithmatex">\(int\)</span> to form <span class="arithmatex">\(\Psi_3\)</span>. Note that we don't need to apply <span class="arithmatex">\(\Psi_1\)</span> to <span class="arithmatex">\(T_2\)</span> during the unification, because <span class="arithmatex">\(T_2\)</span> is infered from <span class="arithmatex">\(\Psi_1(\Gamma)\)</span>, i.e. type variables in <span class="arithmatex">\(T_2\)</span> is either already in the domain of <span class="arithmatex">\(\Psi_1(\Gamma)\)</span>, or it is enirely fresh, i.e. not in <span class="arithmatex">\(T_1\)</span> and <span class="arithmatex">\(\Psi_1\)</span>. We return <span class="arithmatex">\(\Psi_3 \circ \Psi_2 \circ \Psi_1\)</span> as the final substitution. </p>
<p>In rule <span class="arithmatex">\({\tt (wOp2)}\)</span>, the binary operator is an equality check. It works similar to the rule <span class="arithmatex">\({\tt (wOp1)}\)</span> except that we return <span class="arithmatex">\(bool\)</span> as the result type, and we do not include <span class="arithmatex">\(int\)</span> as the additional operand when unifying the the types of <span class="arithmatex">\(\Psi_2(T_1)\)</span> and <span class="arithmatex">\(T_2\)</span>. </p>
<div class="arithmatex">\[
\begin{array}{rc}
{\tt (wIf)} &amp; \begin{array}{c}
                \Gamma, t_1 \vDash T_1, \Psi_1\ \ \
                \Psi_1' = mgu(bool, T_1) \circ \Psi_1 \\
                \Psi_1'(\Gamma),t_2 \vDash T_2, \Psi_2 \ \ \
                \Psi_1'(\Gamma),t_3 \vDash T_3, \Psi_3 \\
                \Psi_4 = mgu(\Psi_3(T_2), \Psi_2(T_3)) 
                \\ \hline
                \Gamma, if\ t_1\ then\ t_2\ else\ t_3 \vDash \Psi_4(\Psi_3(T_2)),  \Psi_4 \circ \Psi_3 \circ \Psi_2 \circ \Psi_1'
              \end{array}
\end{array}
\]</div>
<p>In the rule <span class="arithmatex">\({\tt (wIf)}\)</span>, we infer the type of <span class="arithmatex">\(if\ t_1\ then\ t_2\ else\ t_3\)</span>. In the premises, we first infer the type of <span class="arithmatex">\(t_1\)</span> to be type <span class="arithmatex">\(T_1\)</span> and type subsitution <span class="arithmatex">\(\Psi_1\)</span>. Since <span class="arithmatex">\(t_1\)</span> is used as a condition expression, we define a refined substitution <span class="arithmatex">\(\Psi_1'\)</span> by unifing <span class="arithmatex">\(bool\)</span> with <span class="arithmatex">\(T_1\)</span> and composing the result with <span class="arithmatex">\(\Psi_1\)</span>. We then apply <span class="arithmatex">\(\Psi_1'\)</span> to <span class="arithmatex">\(\Gamma\)</span> and infer <span class="arithmatex">\(t_2\)</span> and <span class="arithmatex">\(t_3\)</span>. 
Finally we unify the returned types from both branches, i.e. <span class="arithmatex">\(\Psi_3(T_2)\)</span> and <span class="arithmatex">\(\Psi_2(T_3)\)</span>. Note that we have to cross apply the type substitutions to ground some type variables. We return <span class="arithmatex">\(\Psi_4(\Psi_2(T_2))\)</span> as the overall inferred type and <span class="arithmatex">\(\Psi_4 \circ \Psi_3 \circ \Psi_2 \circ \Psi_1'\)</span> as the overall type substitution. </p>
<h3 id="helper-functions">Helper functions</h3>
<p>We find the list of helper functions defined in Algorithm W.</p>
<h4 id="type-substitution">Type Substitution</h4>
<div class="arithmatex">\[
\begin{array}{rcl}
\Psi(\Gamma)  &amp;= &amp; \{ (x,\Psi(\sigma)) \mid (x,\sigma) \in \Gamma \}
\end{array}
\]</div>
<h4 id="type-instantiation">Type Instantiation</h4>
<div class="arithmatex">\[
\begin{array}{rcl}
inst(T) &amp; = &amp; T \\
inst(\forall \alpha.\sigma) &amp; = &amp; \lbrack\beta_1/\alpha\rbrack(inst(\sigma))\ where\ \beta_1=newvar \\
\end{array}
\]</div>
<p>The type instantation function instantiate a type scheme. In case of a simple type <span class="arithmatex">\(T\)</span>, it returns <span class="arithmatex">\(T\)</span>. In case it is a polymorphic type scheme <span class="arithmatex">\(\forall \alpha.\sigma\)</span>, we generate a new skolem type variable <span class="arithmatex">\(\beta_1\)</span> and replace all the occurances of <span class="arithmatex">\(\alpha\)</span> in <span class="arithmatex">\(inst(\sigma)\)</span>. In some literature, these skolem type variables are called the unification type variables as they are created for the purpose of unification.</p>
<h4 id="type-generalization">Type Generalization</h4>
<div class="arithmatex">\[
\begin{array}{rcl}
gen(\Gamma, T) &amp; = &amp; \forall \overline{\alpha}.T\ \ where\ \overline{\alpha} = ftv(T) - ftv(\Gamma)
\end{array}
\]</div>
<p>The type generation function turns a type <span class="arithmatex">\(T\)</span> into a type scheme if there exists some free type variable in <span class="arithmatex">\(T\)</span> but not in <span class="arithmatex">\(ftv(\Gamma)\)</span>, i.e. skolem variables. </p>
<h4 id="type-unification">Type Unification</h4>
<div class="arithmatex">\[
\begin{array}{rcl}
mgu(\alpha, T) &amp; = &amp; [T/\alpha] \\ 
mgu(T, \alpha) &amp; = &amp; [T/\alpha] \\ 
mgu(int, int) &amp; = &amp; [] \\ 
mgu(bool, bool) &amp; = &amp; [] \\ 
mgu(T_1 \rightarrow T_2 , T_3\rightarrow T_4) &amp; = &amp; let\ \Psi_1 = mgu(T_1, T_3)\ \\ 
&amp;  &amp; in\ \ let\ \Psi_2 = mgu(\Psi_1(T_2), \Psi_1(T_4)) \\
&amp;  &amp; \ \ \ \ \ in\ \Psi_2 \circ \Psi_1
\end{array}
\]</div>
<p>The type unification process is similar to the one described for SIMP program type inference, except that we included an extra case for function type unification. In the event of unifying two function types <span class="arithmatex">\(T_1 \rightarrow T_2\)</span> and <span class="arithmatex">\(T_3 \rightarrow T_4\)</span>, we first unify the argument types <span class="arithmatex">\(T_1\)</span> and <span class="arithmatex">\(T_3\)</span> then apply the result to <span class="arithmatex">\(T_2\)</span> and <span class="arithmatex">\(T_4\)</span> and unify them.</p>
<h3 id="examples">Examples</h3>
<p>Let's consider some examples </p>
<h4 id="example-1-lambda-xx">Example 1 <span class="arithmatex">\(\lambda x.x\)</span></h4>
<p>Let <span class="arithmatex">\(\Gamma = \{(fix,\forall \alpha. (\alpha \rightarrow \alpha) \rightarrow \alpha)\}\)</span></p>
<pre><code class="language-haskell">           (x,α1)∈Γ⊕(x,α1)  inst(α1)=α1
           ----------------------------(wVar)
α1=newvar  Γ⊕(x,α1),x|=α1,[]
------------------------------------------(wLam)
Γ,λx.x|= α1-&gt;α1, []
</code></pre>
<h4 id="example-2-lambda-xlambda-yx">Example 2 <span class="arithmatex">\(\lambda x.\lambda y.x\)</span></h4>
<pre><code class="language-haskell">                     (x,β1)∈Γ⊕(x,β1)⊕(y,γ1) inst(β1)=β1
                     --------------------------------(wVar)
           γ1=newvar Γ⊕(x,β1)⊕(y,γ1),x|= β1,[]
           --------------------------------------(wLam)
β1=newvar  Γ⊕(x,β1),λy.x|=γ1-&gt;β1,[]
-------------------------------------------------(wLam)
Γ,λx.λy.x|= β1-&gt;γ1-&gt;β1,[]
</code></pre>
<h4 id="example-3-let-flambda-xx-in-let-glambda-xlambda-yx-in-g-f-1-f-true">Example 3 <span class="arithmatex">\(let\ f=\lambda x.x\ in\ (let\ g=\lambda x.\lambda y.x\ in\ g\ (f\ 1)\ (f\ true))\)</span></h4>
<pre><code class="language-haskell">[Example 1]
-------------------
Γ,λx.x|= α1-&gt;α1, []   gen(Γ,α1-&gt;α1)=∀α.α-&gt;α  [subtree 1]
------------------------------------------------------------------(wLet)
Γ,let f=λx.x in (let g=λx.λy.x in g (f 1) (f true))|= int, Ψ3○[bool/γ2,int/δ1]
</code></pre>
<p>Let <code>Γ1 =Γ⊕(f,∀α.α-&gt;α)</code>, where [subtree 1] is </p>
<pre><code class="language-haskell">[Example 2]
--------------------------   
Γ1,λx.λy.x|= β1-&gt;γ1-&gt;β1,[]  gen(Γ1,β1-&gt;γ1-&gt;β1)=∀β.∀γ.β-&gt;γ-&gt;β [subtree 2] 
-------------------------------------------------------------------------------(wLet)
Γ1,let g=λx.λy.x in g (f 1) (f true)|=int, Ψ3○[bool/γ2,int/δ1]○[]
</code></pre>
<p>Let <code>Γ2 =Γ⊕(f,∀α.α-&gt;α)⊕(g,∀β.∀γ.β-&gt;γ-&gt;β)</code>, where [subtree 2] is</p>
<pre><code class="language-haskell">[subtree 3]  [subtree 5] δ1=newvar  mgu(γ2-&gt;int,bool-&gt;δ1)=[bool/γ2,int/δ1]
--------------------------------------------------------------------------(wApp)
Γ2, g (f 1) (f true)|= [bool/γ2,int/δ1](δ1), Ψ3○[bool/γ2,int/δ1]
</code></pre>
<p>Where [subtree 3] is</p>
<pre><code class="language-haskell">(g,∀β.∀γ.β-&gt;γ-&gt;β)∈Γ2                 ε1=newvar
inst(∀β.∀γ.β-&gt;γ-&gt;β)=β2-&gt;γ2-&gt;β2       mgu(β2-&gt;γ2-&gt;β2,int-&gt;ε1)=[int/β2,γ2-&gt;int/ε1]
--------------------------(wVar)    
Γ2, g|=β2-&gt;γ2-&gt;β2, []        [subtree 4]
---------------------------------------------------------------------(wApp)
Γ2, g (f 1)|= [int/β2,γ2-&gt;int/ε1](ε1),[int/β2,γ2-&gt;int/ε1]○[int/ζ1,int/α2]
</code></pre>
<p>Where [subtree 4] is </p>
<pre><code class="language-haskell">(f,∀α.α-&gt;α)∈Γ2 
inst(∀α.α-&gt;α)=α2-&gt;α2                      ζ1=newvar
-----------------(wVar) ------------(wInt)    
Γ2, f|=α2-&gt;α2,[]        Γ2,1|=int,[]      mgu(α2-&gt;α2,int-&gt;ζ1)=[int/ζ1,int/α2]
---------------------------------------------------------------------(wApp)
[](Γ2),f 1|= [int/ζ1,int/α2](ζ1), [int/ζ1,int/α2]
</code></pre>
<p>Let <code>Ψ3=[int/β2,γ2-&gt;int/ε1]○[int/ζ1,int/α2]</code>, note that <code>Ψ3(Γ2) =Γ2</code>,  where [subtree 5] is </p>
<pre><code class="language-haskell">(f,∀α.α-&gt;α)∈Γ2
inst(∀α.α-&gt;α)=α3-&gt;α3                      η1=newvar
----------------(wVar) ----------(wBool) 
Γ2,f|=α3-&gt;α3, []       Γ2,true|=bool,[]   mgu(α3-&gt;α3,bool-&gt;η1)=[bool/α3,bool/η1]
-----------------------------------------------------------------------[wApp]
Γ2,f true|=[bool/α3,bool/η1](α3),[bool/α3,bool/η1]
</code></pre>
<h3 id="property-7-type-inference-soundness">Property 7: Type Inference Soundness</h3>
<p>The following property states that the type and subsitution generated by Algorithm W is able to type check the lambda calculus term in Hindley Milners' type system.</p>
<p>Let <span class="arithmatex">\(t\)</span> be a lambda calculus term and <span class="arithmatex">\(\Gamma_{init}\)</span> is a initial type environment and <span class="arithmatex">\(\Gamma_{init}, t \vDash T, \Psi\)</span>. Then <span class="arithmatex">\(\Gamma \vdash t:gen(\Gamma_{init},\Psi(T))\)</span>. </p>
<h3 id="property-8-principality">Property 8: Principality</h3>
<p>The following property states that the type generated by Algorithm W is the principal type.</p>
<p>Let <span class="arithmatex">\(t\)</span> be a lambda calculus term and <span class="arithmatex">\(\Gamma_{init}\)</span> is a initial type environment and <span class="arithmatex">\(\Gamma_{init}, t \vDash T, \Psi\)</span>.
Then <span class="arithmatex">\(gen(\Gamma_{init}, \Psi(T))\)</span> is the most general type scheme to type check <span class="arithmatex">\(t\)</span>. </p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/jquery-3.6.0.min.js"></script>
        <script src="../../js/bootstrap.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../javascripts/mathjax.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
